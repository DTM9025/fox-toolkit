/********************************************************************************
*                                                                               *
*                     D i r e c t o r y   L i s t   O b j e c t                 *
*                                                                               *
*********************************************************************************
* Copyright (C) 1998 by Jeroen van der Zijp.   All Rights Reserved.             *
*********************************************************************************
* This library is free software; you can redistribute it and/or                 *
* modify it under the terms of the GNU Library General Public                   *
* License as published by the Free Software Foundation; either                  *
* version 2 of the License, or (at your option) any later version.              *
*                                                                               *
* This library is distributed in the hope that it will be useful,               *
* but WITHOUT ANY WARRANTY; without even the implied warranty of                *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU             *
* Library General Public License for more details.                              *
*                                                                               *
* You should have received a copy of the GNU Library General Public             *
* License along with this library; if not, write to the Free                    *
* Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.            *
*********************************************************************************
* $Id: FXDirList.cpp,v 1.33 1998/09/17 04:35:13 jeroen Exp $                     *
********************************************************************************/
#include "xincs.h"
#include "fxdefs.h"
#include "fxkeys.h"
#include "FXStream.h"
#include "FXString.h"
#include "FXObject.h"
#include "FXAccelTable.h"
#include "FXObjectList.h"
#include "FXApp.h"
#include "FXId.h"
#include "FXFont.h"
#include "FXDrawable.h"
#include "FXImage.h"
#include "FXIcon.h"
#include "FXGIFIcon.h"
#include "FXWindow.h"
#include "FXFrame.h"
#include "FXLabel.h"
#include "FXButton.h"
#include "FXComposite.h"
#include "FXCanvas.h"
#include "FXShell.h"
#include "FXScrollbar.h"
#include "FXScrollWindow.h"
#include "FXTreeList.h"
#include "FXDirList.h"


// Private headers
#include "FXTreeItem.h"
#include "FXDirItem.h"


/*
  To do:
  - Ownership issues of icons.
  - Should create root item in refresh (I think!)
  - Instead of FXTreeItems, callbacks should pass pointer to directory
*/


#define REFRESHINTERVAL 2000
#define ID_REFRESH      100

/*******************************************************************************/

/* Generated by reswrap from file minifolderopen.gif */
const unsigned char minifolderopen[]={
  0x47,0x49,0x46,0x38,0x37,0x61,0x10,0x00,0x10,0x00,0xf2,0x00,0x00,0xb2,0xc0,0xdc,
  0x00,0x00,0x00,0x7f,0x7f,0x7f,0xff,0xff,0xff,0xd9,0xd9,0xd9,0xff,0xff,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x03,
  0x42,0x08,0xba,0xdc,0x2c,0x10,0xba,0x37,0x6a,0x15,0x13,0x88,0x41,0x4a,0x27,0x43,
  0x14,0x29,0x9b,0x67,0x82,0x56,0x18,0x68,0xdc,0xe9,0x12,0x42,0x20,0xce,0x62,0x11,
  0x6f,0x69,0x1e,0xc3,0x72,0xfb,0xb9,0xb2,0x18,0xeb,0x47,0xbc,0xad,0x4a,0xc4,0x93,
  0x6c,0xc5,0x7a,0x99,0x62,0x4c,0x1a,0x2d,0xc0,0x04,0x50,0xaf,0x58,0x6c,0x66,0xcb,
  0x6d,0x24,0x00,0x00,0x3b
  };

/* Generated by reswrap from file minifolderclosed.gif */
const unsigned char minifolderclosed[]={
  0x47,0x49,0x46,0x38,0x37,0x61,0x10,0x00,0x10,0x00,0xf2,0x00,0x00,0xb2,0xc0,0xdc,
  0x80,0x80,0x80,0xc0,0xc0,0xc0,0xff,0xff,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x03,
  0x3b,0x08,0xba,0xdc,0x1b,0x10,0x3a,0x16,0xc4,0xb0,0x22,0x4c,0x50,0xaf,0xcf,0x91,
  0xc4,0x15,0x64,0x69,0x92,0x01,0x31,0x7e,0xac,0x95,0x8e,0x58,0x7b,0xbd,0x41,0x21,
  0xc7,0x74,0x11,0xef,0xb3,0x5a,0xdf,0x9e,0x1c,0x6f,0x97,0x03,0xba,0x7c,0xa1,0x64,
  0x48,0x05,0x20,0x38,0x9f,0x50,0xe8,0x66,0x4a,0x75,0x24,0x00,0x00,0x3b
  };

/* Generated by reswrap from file minidoc.gif */
const unsigned char minidoc[]={
  0x47,0x49,0x46,0x38,0x37,0x61,0x10,0x00,0x10,0x00,0xf2,0x00,0x00,0xbf,0xbf,0xbf,
  0x80,0x80,0x80,0xff,0xff,0xff,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x03,
  0x36,0x08,0x10,0xdc,0xae,0x70,0x89,0x49,0xe7,0x08,0x51,0x56,0x3a,0x04,0x86,0xc1,
  0x46,0x11,0x24,0x01,0x8a,0xd5,0x60,0x2a,0x21,0x6a,0xad,0x9a,0xab,0x9e,0xae,0x30,
  0xb3,0xb5,0x0d,0xb7,0xf2,0x9e,0xdf,0x31,0x14,0x90,0x27,0xf4,0xd5,0x86,0x83,0xa4,
  0x72,0x09,0x2c,0x39,0x9f,0xa6,0x04,0x00,0x3b
  };
  
  
/*******************************************************************************/

// Map
FXDEFMAP(FXDirList) FXDirListMap[]={
  FXMAPFUNC(SEL_TIMEOUT,1000,FXDirList::onRefresh),
  FXMAPFUNC(SEL_EXPANDED,0,FXDirList::onItemExpanded),
  FXMAPFUNC(SEL_COLLAPSED,0,FXDirList::onItemCollapsed),
  FXMAPFUNC(SEL_SELECTION_REQUEST,0,FXDirList::onSelectionRequest),
  };


// Object implementation
FXIMPLEMENT(FXDirList,FXTreeList,FXDirListMap,ARRAYNUMBER(FXDirListMap))


// Separator item
FXDirList::FXDirList(FXComposite *p,FXObject* tgt,FXSelector sel,FXuint opts,FXint x,FXint y,FXint w,FXint h):
  FXTreeList(p,tgt,sel,opts,x,y,w,h){
  open_folder=new FXGIFIcon(getApp(),minifolderopen);
  closed_folder=new FXGIFIcon(getApp(),minifolderclosed);
  mini_doc=new FXGIFIcon(getApp(),minidoc);
  refresh=NULL;
  sortfunc=cmpName;
  }


// Create X window
void FXDirList::create(){
  FXDirItem *diritem;
  FXTreeList::create();
  refresh=getApp()->addTimeout(1,this,1000);
  open_folder->create();
  closed_folder->create();
  mini_doc->create();
  diritem=(FXDirItem*)createItem();
  firstitem=lastitem=diritem;
  diritem->parent=NULL;
  diritem->next=NULL;
  diritem->prev=NULL;
  diritem->inext=NULL;
  diritem->iprev=NULL;
  diritem->state=0;
  diritem->label="/";
  diritem->first=NULL;
  diritem->last=NULL;
  diritem->openIcon=open_folder;
  diritem->closedIcon=closed_folder;
  }


// Destroy zaps the icons
void FXDirList::destroy(){
  open_folder->destroy();
  closed_folder->destroy();
  mini_doc->destroy();
  FXTreeList::destroy();
  }


// Create item
FXTreeItem* FXDirList::createItem(){ return (FXTreeItem*) new FXDirItem; }


// Compare file names
FXbool FXDirList::cmpName(const FXItem* a,const FXItem* b){
  return strcmp(((FXDirItem*)a)->label.text(),((FXDirItem*)b)->label.text())>=0;
  }


// Refresh
long FXDirList::onRefresh(FXObject* sender,FXSelector sel,void*){
  FXbool changed;
  changed=scanDirectory((FXDirItem*)firstitem);
  if(changed) recalc();
  refresh=getApp()->addTimeout(REFRESHINTERVAL,this,1000);
  return 1;
  }


// Somebody wants our selection
long FXDirList::onSelectionRequest(FXObject* sender,FXSelector sel,void* ptr){
  FXuchar *data; 
//fprintf(stderr,"%s::onSelectionRequest %x\n",getClassName(),this);
  
  // Try handle through base class first
  if(FXTreeList::onSelectionRequest(sender,sel,ptr)) return 1;
  
  // Otherwise (most likely) its the string from this text we return
  // Strictly speaking, we should return ALL selected items, not just the current
  // one....
  if(currentitem && isItemSelected(currentitem)){
    if(getDNDType()==XA_STRING){
      FXCALLOC(&data,FXuchar,MAXPATHLEN+1);
      getpath(currentitem,(FXchar*)data);
      setDNDData(XA_STRING,data,strlen((FXchar*)data));
      }
    }
  return 0;
  }


// Item opened
long FXDirList::onItemExpanded(FXObject* sender,FXSelector sel,void* ptr){
  FXDirItem *item=(FXDirItem*)ptr;
  FXbool changed;
  FXTreeList::onItemExpanded(sender,sel,ptr);
//fprintf(stderr,"onItemExpanded %s\n",item->label.text());
  changed=listDirectory(item);
  listSubDirectories(item);
  if(changed){
    sortDirectory(item);
    recalc();
    }
  else{
    update(0,0,width,height);
    }
  return 1;
  }


// Item closed
long FXDirList::onItemCollapsed(FXObject* sender,FXSelector sel,void* ptr){
  FXDirItem *item=(FXDirItem*)ptr;
  FXTreeList::onItemCollapsed(sender,sel,ptr);
//fprintf(stderr,"onItemCollapsed %s\n",item->label.text());
  return 1;
  }


// Helper function 
FXchar *FXDirList::getpath(FXTreeItem* item,FXchar* pathname){
  register const FXchar *ptr;
  if(!item->parent){
    *pathname++=PATHSEP;
    }
  else{
    pathname=getpath(item->parent,pathname);
    if(*(pathname-1)!=PATHSEP){*pathname++=PATHSEP;}
    ptr=item->label.text();
    if(ptr){ while(*ptr){*pathname++=*ptr++;} }
    }
  *pathname='\0';
  return pathname;
  }


// Determine path of item
FXchar*  FXDirList::itempath(FXDirItem* item,FXchar* pathname){
  getpath(item,pathname);
  return pathname;
  }


// Sort items under parent
FXbool FXDirList::sortDirectory(FXDirItem *par){
  if(!sortfunc) return FALSE;
  FXItem *f=(FXItem*)par->first;
  FXItem *l=(FXItem*)par->last;
  fxsort((FXItem*&)par->first,(FXItem*&)par->last,f,l,sortfunc,getNumChildItems(par));
  return TRUE;
  }


// List items under parent
FXbool FXDirList::listDirectory(FXDirItem *par){
  FXbool changed=FALSE;
#ifndef WIN32
  FXchar pathname[MAXPATHLEN],*pathtail,*name;
  FXDirItem *after,*before,*newlist,*item,*it;
  struct stat info;
  struct dirent *dp;
  int islink;
  DIR *dirp;

  // Get pathname of item
  getpath(par,pathname);
  
//fprintf(stderr,"listDirectory %s\n",pathname);
  // Stat directory
  if(stat(pathname,&info)!=0) return FALSE;
  
  // Still valid?
  if(par->timestamp==info.st_mtime) return FALSE;
  
  // Changed, update time stamp
  par->timestamp=info.st_mtime;
  
  // Get directory stream pointer
  dirp=opendir(pathname);
  if(!dirp) return FALSE;

  // Tail end
  pathtail=pathname+strlen(pathname)-1;
  if(*pathtail!=PATHSEP) *++pathtail=PATHSEP;
  ++pathtail;
  
  // Build new insert-order list
  after=NULL;
  before=par->list;
  newlist=NULL;

  // Process directory entries
  while((dp=readdir(dirp))!=NULL){
    name=dp->d_name;

    // A dot special file?
    if(name[0]=='.' && (name[1]==0 || (name[1]=='.' && name[2]==0))) continue;

    // File name or dir name to stat
    strcpy(pathtail,name);
//fprintf(stderr,"statting %s\n",pathname);

    // Get File info
    if(lstat(pathname,&info)!=0) continue;

    // If its a link, get the file info
    islink=S_ISLNK(info.st_mode);
    if(islink && stat(pathname,&info)!=0) continue;

    // If not a directory, skip it
    if(!S_ISDIR(info.st_mode)) continue;

//fprintf(stderr,"searching %s...",name);
    // Find it
    for(item=before; item; item=item->inext){
      if(strcmp(item->label.text(),name)==0){
//fprintf(stderr,"found\n");
        while(before!=item){
          it=before;
          before=before->inext;
          if(it->prev) it->prev->next=it->next; else if(it->parent) it->parent->first=it->next; else firstitem=it->next;
          if(it->next) it->next->prev=it->prev; else if(it->parent) it->parent->last=it->prev;  else lastitem=it->prev;
          if(currentitem==it) currentitem=NULL;
          if(anchoritem==it) anchoritem=NULL;
          removeItems(it->first,it->last);
          changed=TRUE;
          delete it;
          }
        before=item->inext;
        if(before) before->iprev=NULL;
        item->inext=NULL;
        item->iprev=NULL;
        goto fnd;
        }
      }
//fprintf(stderr,"not found\n");

    // Not found; prepend before list
    item=(FXDirItem*)createItem();
    item->prev=par->last;
    item->next=NULL;
    item->iprev=NULL;
    item->inext=NULL;
    item->list=NULL;
    item->first=NULL;
    item->last=NULL;
    item->state=0;
    item->parent=par;
    item->timestamp=0;
    if(item->prev) item->prev->next=item; else par->first=item;
    par->last=item;
    changed=TRUE;

fnd:item->iprev=after;
    if(after) after->inext=item; else newlist=item;

    // Update item with new info
    item->label=name;
    item->openIcon=open_folder;
    item->closedIcon=closed_folder;/// If icon changed...

    // Next one goes after item
    after=item;
    }

  // Wipe items remaining in list:- they have disappeared!!
  while(before){
    it=before;
    before=before->inext;
    if(it->prev) it->prev->next=it->next; else if(it->parent) it->parent->first=it->next; else firstitem=it->next;
    if(it->next) it->next->prev=it->prev; else if(it->parent) it->parent->last=it->prev; else lastitem=it->prev;
    if(currentitem==it) currentitem=NULL;
    if(anchoritem==it) anchoritem=NULL;
    removeItems(it->first,it->last);
    changed=TRUE;
    delete it;
    }

  // Remember new list
  par->list=newlist;

  // Close it
  closedir(dirp);
#endif
  return changed;
  }


// List subdirectories
FXbool FXDirList::listSubDirectories(FXDirItem *par){
  FXbool changed=FALSE;
#ifndef WIN32
  FXDirItem *item;
  for(item=(FXDirItem*)par->first; item; item=(FXDirItem*)item->next){
    if(listDirectory(item)){
      sortDirectory(item);
      changed=TRUE;
      }
    }
#endif
  return changed;
  }


// Scan directory for changes
// It has to be breadth-first, as directories may disappear or
// appear during the scanning process.
FXbool FXDirList::scanDirectory(FXDirItem *par){
  FXbool changed;
  FXDirItem *item;

  // Check this directory
  changed=listDirectory(par); 
  if(changed) sortDirectory(par);
  
  // Check subitems 
  for(item=(FXDirItem*)par->first; item; item=(FXDirItem*)item->next){
    if(isItemExpanded(par)){
      changed|=scanDirectory(item);
      }
    }
  return changed;
  }


// Cleanup
FXDirList::~FXDirList(){
  if(refresh) getApp()->removeTimeout(refresh);
  delete closed_folder;
  delete open_folder;
  delete mini_doc;
  closed_folder=(FXGIFIcon*)-1;
  open_folder=(FXGIFIcon*)-1;
  mini_doc=(FXGIFIcon*)-1;
  refresh=(FXTimer*)-1;
  }


