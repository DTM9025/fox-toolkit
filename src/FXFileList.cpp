/********************************************************************************
*                                                                               *
*                        F i l e    L i s t   O b j e c t                       *
*                                                                               *
*********************************************************************************
* Copyright (C) 1998 by Jeroen van der Zijp.   All Rights Reserved.             *
*********************************************************************************
* This library is free software; you can redistribute it and/or                 *
* modify it under the terms of the GNU Library General Public                   *
* License as published by the Free Software Foundation; either                  *
* version 2 of the License, or (at your option) any later version.              *
*                                                                               *
* This library is distributed in the hope that it will be useful,               *
* but WITHOUT ANY WARRANTY; without even the implied warranty of                *
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU             *
* Library General Public License for more details.                              *
*                                                                               *
* You should have received a copy of the GNU Library General Public             *
* License along with this library; if not, write to the Free                    *
* Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.            *
*********************************************************************************
* $Id: FXFileList.cpp,v 1.63 1998/10/23 22:07:36 jvz Exp $                   *
********************************************************************************/
#include "xincs.h"
#include "fxdefs.h"
#include "fxkeys.h"
#include "FXStream.h"
#include "FXString.h"
#include "FXObject.h"
#include "FXAccelTable.h"
#include "FXObjectList.h"
#include "FXApp.h"
#include "FXId.h"
#include "FXFont.h"
#include "FXDrawable.h"
#include "FXImage.h"
#include "FXIcon.h"
#include "FXGIFIcon.h"
#include "FXWindow.h"
#include "FXFrame.h"
#include "FXLabel.h"
#include "FXButton.h"
#include "FXComposite.h"
#include "FXCanvas.h"
#include "FXShell.h"
#include "FXScrollbar.h"
#include "FXScrollWindow.h"
#include "FXHeader.h"
#include "FXIconList.h"
#include "FXFileList.h"


// Private headers
#include "FXIconItem.h"
#include "FXFileItem.h"

/*
  To do:
  - Fix (at least) hard-wired icons 
  - Icon ownership issues.
  - When an item is selected, we should acquire selection; so if another
    application does a paste, it will get the full pathname.
  - Of course, vice versa a paste of a dirname in the FXFileList should
    switch it to the directory...
  - Instead of FXIconItems, callbacks should pass filename.
  - Translate onClicked etc into opened/launched, etc messages
  - ID_SETSTRINGVALUE etc messages so we can connect text fields with
    FXFileList...
*/


#define REFRESHINTERVAL 2000



/*******************************************************************************/

/* Generated by reswrap from file bigapp.gif */
const unsigned char bigapp[]={
  0x47,0x49,0x46,0x38,0x37,0x61,0x20,0x00,0x20,0x00,0xf2,0x00,0x00,0xb2,0xc0,0xdc,
  0x80,0x80,0x80,0x00,0x00,0x00,0xc0,0xc0,0xc0,0x00,0x00,0x80,0xff,0xff,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x20,0x00,0x20,0x00,0x00,0x03,
  0x82,0x08,0xba,0xdc,0xfe,0x2c,0xc8,0x49,0xab,0xbd,0x53,0x84,0xc1,0xbb,0xff,0x60,
  0x38,0x04,0xda,0x40,0x9c,0x68,0xaa,0xae,0x2c,0xb9,0xb1,0x70,0xca,0x09,0xf3,0xec,
  0x9a,0x71,0x5c,0x0f,0x34,0x7f,0xe7,0x31,0x81,0x70,0x38,0xbc,0x89,0x8e,0xc8,0x51,
  0x09,0xc3,0x6c,0x2a,0x37,0x81,0x82,0x74,0x4a,0xad,0x5a,0xab,0xcf,0xd1,0x75,0xcb,
  0x95,0x66,0xa3,0xdd,0x30,0xf5,0x2b,0x2e,0x17,0xc8,0xe6,0x30,0x3a,0xcd,0x5d,0xb3,
  0xaf,0xee,0x37,0xf6,0x06,0x96,0x5b,0xe3,0x76,0x2f,0x3d,0x7f,0xdf,0xf3,0xc7,0x7e,
  0x7f,0x7a,0x4b,0x82,0x53,0x78,0x79,0x87,0x76,0x89,0x72,0x8b,0x6f,0x59,0x49,0x90,
  0x1f,0x2e,0x4d,0x94,0x4c,0x44,0x97,0x98,0x99,0x9a,0x43,0x10,0x9d,0x9e,0x9f,0xa0,
  0xa1,0x00,0x09,0x00,0x3b
  };

/* Generated by reswrap from file miniapp.gif */
const unsigned char miniapp[]={
  0x47,0x49,0x46,0x38,0x37,0x61,0x10,0x00,0x10,0x00,0xf2,0x00,0x00,0xb2,0xc0,0xdc,
  0x80,0x80,0x80,0xc0,0xc0,0xc0,0x00,0x00,0x00,0xff,0xff,0xff,0x00,0x00,0x80,0x00,
  0x00,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x03,
  0x38,0x08,0xba,0xdc,0x10,0x30,0xca,0x09,0x85,0xbd,0xf8,0x86,0x11,0x44,0xf9,0x60,
  0xf8,0x6d,0x9d,0x58,0x10,0x03,0x8a,0x92,0x02,0xe5,0x72,0x02,0x21,0xcf,0xb4,0xcc,
  0xd6,0x38,0x71,0xe7,0xf4,0xce,0xdb,0xb0,0xdf,0xcc,0xf7,0x23,0xf2,0x48,0xae,0xd7,
  0x60,0xc9,0x6c,0x3a,0x07,0x8e,0xe8,0x22,0x01,0x00,0x3b
  };

/* Generated by reswrap from file bigdoc.gif */
const unsigned char bigdoc[]={
  0x47,0x49,0x46,0x38,0x37,0x61,0x20,0x00,0x20,0x00,0xf2,0x00,0x00,0xbf,0xbf,0xbf,
  0x80,0x80,0x80,0xff,0xff,0xff,0x00,0x00,0x00,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x20,0x00,0x20,0x00,0x00,0x03,
  0x79,0x08,0x0a,0xd1,0xfe,0xf0,0xad,0x49,0x99,0xb8,0x38,0xeb,0x1b,0x46,0xad,0xc1,
  0x26,0x66,0x8d,0xf7,0x2d,0xe1,0x38,0x06,0x44,0x77,0x2a,0xa9,0xba,0x85,0xad,0xf9,
  0xc5,0x32,0x79,0xd5,0x27,0x9e,0x73,0x83,0xa0,0xf0,0xf6,0x93,0x11,0x6c,0x13,0x5f,
  0x31,0x73,0x24,0x2e,0x45,0x4d,0xd0,0x13,0x8a,0x44,0x4d,0x37,0x51,0x8a,0x72,0x9a,
  0x4d,0x5e,0x35,0x5d,0xeb,0x17,0x13,0x86,0x8d,0xc9,0x55,0xf3,0x59,0x50,0xb6,0xac,
  0xdb,0xdb,0x27,0x7c,0xcd,0x4e,0xbb,0xcf,0xf3,0xb7,0x3d,0xbe,0xcc,0xe3,0xf7,0x74,
  0x7e,0x63,0x82,0x5f,0x84,0x57,0x86,0x5c,0x80,0x7a,0x37,0x04,0x8d,0x8e,0x8f,0x90,
  0x91,0x8d,0x76,0x42,0x95,0x96,0x97,0x98,0x0b,0x09,0x00,0x3b
  };
  
  
/* Generated by reswrap from file minidoc.gif */
const unsigned char minidoc[]={
  0x47,0x49,0x46,0x38,0x37,0x61,0x10,0x00,0x10,0x00,0xf2,0x00,0x00,0xbf,0xbf,0xbf,
  0x80,0x80,0x80,0xff,0xff,0xff,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x03,
  0x36,0x08,0x10,0xdc,0xae,0x70,0x89,0x49,0xe7,0x08,0x51,0x56,0x3a,0x04,0x86,0xc1,
  0x46,0x11,0x24,0x01,0x8a,0xd5,0x60,0x2a,0x21,0x6a,0xad,0x9a,0xab,0x9e,0xae,0x30,
  0xb3,0xb5,0x0d,0xb7,0xf2,0x9e,0xdf,0x31,0x14,0x90,0x27,0xf4,0xd5,0x86,0x83,0xa4,
  0x72,0x09,0x2c,0x39,0x9f,0xa6,0x04,0x00,0x3b
  };

/* Generated by reswrap from file bigfolder.gif */
const unsigned char bigfolder[]={
  0x47,0x49,0x46,0x38,0x37,0x61,0x20,0x00,0x20,0x00,0xf2,0x00,0x00,0xb2,0xc0,0xdc,
  0x80,0x80,0x80,0xff,0xff,0xff,0xff,0xff,0x00,0xc0,0xc0,0xc0,0x00,0x00,0x00,0x80,
  0x80,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x20,0x00,0x20,0x00,0x00,0x03,
  0x83,0x08,0xba,0xdc,0xfe,0x30,0xca,0x49,0x6b,0x0c,0x38,0x67,0x0b,0x83,0xf8,0x20,
  0x18,0x70,0x8d,0x37,0x10,0x67,0x8a,0x12,0x23,0x09,0x98,0xab,0xaa,0xb6,0x56,0x40,
  0xdc,0x78,0xae,0x6b,0x3c,0x5f,0xbc,0xa1,0xa0,0x70,0x38,0x2c,0x14,0x60,0xb2,0x98,
  0x32,0x99,0x34,0x1c,0x05,0xcb,0x28,0x53,0xea,0x44,0x4a,0xaf,0xd3,0x2a,0x74,0xca,
  0xc5,0x6a,0xbb,0xe0,0xa8,0x16,0x4b,0x66,0x7e,0xcb,0xe8,0xd3,0x38,0xcc,0x46,0x9d,
  0xdb,0xe1,0x75,0xba,0xfc,0x9e,0x77,0xe5,0x70,0xef,0x33,0x1f,0x7f,0xda,0xe9,0x7b,
  0x7f,0x77,0x7e,0x7c,0x7a,0x56,0x85,0x4d,0x84,0x82,0x54,0x81,0x88,0x62,0x47,0x06,
  0x91,0x92,0x93,0x94,0x95,0x96,0x91,0x3f,0x46,0x9a,0x9b,0x9c,0x9d,0x9e,0x9a,0x2e,
  0xa1,0xa2,0x13,0x09,0x00,0x3b
  };

/* Generated by reswrap from file minifolder.gif */
const unsigned char minifolder[]={
  0x47,0x49,0x46,0x38,0x37,0x61,0x10,0x00,0x10,0x00,0xf2,0x00,0x00,0xb2,0xc0,0xdc,
  0x80,0x80,0x80,0xc0,0xc0,0xc0,0xff,0xff,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x03,
  0x3b,0x08,0xba,0xdc,0x1b,0x10,0x3a,0x16,0xc4,0xb0,0x22,0x4c,0x50,0xaf,0xcf,0x91,
  0xc4,0x15,0x64,0x69,0x92,0x01,0x31,0x7e,0xac,0x95,0x8e,0x58,0x7b,0xbd,0x41,0x21,
  0xc7,0x74,0x11,0xef,0xb3,0x5a,0xdf,0x9e,0x1c,0x6f,0x97,0x03,0xba,0x7c,0xa1,0x64,
  0x48,0x05,0x20,0x38,0x9f,0x50,0xe8,0x66,0x4a,0x75,0x24,0x00,0x00,0x3b
  };


// Default path for the widget
const FXchar defpath[]={PATHSEP,'\0'};


/*******************************************************************************/


// Map
FXDEFMAP(FXFileList) FXFileListMap[]={
  FXMAPFUNC(SEL_TIMEOUT,1000,FXFileList::onRefresh),
  FXMAPFUNC(SEL_SELECTION_REQUEST,0,FXFileList::onSelectionRequest),
  FXMAPFUNC(SEL_COMMAND,FXWindow::ID_SETSTRINGVALUE,FXFileList::onCmdSetStringValue),
  FXMAPFUNC(SEL_COMMAND,FXWindow::ID_GETSTRINGVALUE,FXFileList::onCmdGetStringValue),
  FXMAPFUNC(SEL_COMMAND,FXFileList::ID_DIRECTORY_UP,FXFileList::onCmdDirectoryUp),
  FXMAPFUNC(SEL_COMMAND,FXFileList::ID_DIRECTORY_NEW,FXFileList::onCmdDirectoryNew),
  FXMAPFUNC(SEL_COMMAND,FXFileList::ID_SORT_BY_NAME,FXFileList::onCmdSortByName),
  FXMAPFUNC(SEL_COMMAND,FXFileList::ID_SORT_BY_TYPE,FXFileList::onCmdSortByType),
  FXMAPFUNC(SEL_COMMAND,FXFileList::ID_SORT_BY_SIZE,FXFileList::onCmdSortBySize),
  FXMAPFUNC(SEL_COMMAND,FXFileList::ID_SORT_BY_TIME,FXFileList::onCmdSortByTime),
  FXMAPFUNC(SEL_COMMAND,FXFileList::ID_SORT_BY_USER,FXFileList::onCmdSortByUser),
  FXMAPFUNC(SEL_COMMAND,FXFileList::ID_SORT_BY_GROUP,FXFileList::onCmdSortByGroup),
  FXMAPFUNC(SEL_COMMAND,FXFileList::ID_SORT_REVERSE,FXFileList::onCmdSortReverse),
  FXMAPFUNC(SEL_COMMAND,FXFileList::ID_SET_PATTERN,FXFileList::onCmdSetPattern),
  FXMAPFUNC(SEL_COMMAND,FXFileList::ID_SET_DIRECTORY,FXFileList::onCmdSetDirectory),
  FXMAPFUNC(SEL_UPDATE,FXFileList::ID_DIRECTORY_UP,FXFileList::onUpdDirectoryUp),
  FXMAPFUNC(SEL_UPDATE,FXFileList::ID_DIRECTORY_NEW,FXFileList::onUpdDirectoryNew),
  FXMAPFUNC(SEL_UPDATE,FXFileList::ID_SORT_BY_NAME,FXFileList::onUpdSortByName),
  FXMAPFUNC(SEL_UPDATE,FXFileList::ID_SORT_BY_TYPE,FXFileList::onUpdSortByType),
  FXMAPFUNC(SEL_UPDATE,FXFileList::ID_SORT_BY_SIZE,FXFileList::onUpdSortBySize),
  FXMAPFUNC(SEL_UPDATE,FXFileList::ID_SORT_BY_TIME,FXFileList::onUpdSortByTime),
  FXMAPFUNC(SEL_UPDATE,FXFileList::ID_SORT_BY_USER,FXFileList::onUpdSortByUser),
  FXMAPFUNC(SEL_UPDATE,FXFileList::ID_SORT_BY_GROUP,FXFileList::onUpdSortByGroup),
  FXMAPFUNC(SEL_UPDATE,FXFileList::ID_SORT_REVERSE,FXFileList::onUpdSortReverse),
  FXMAPFUNC(SEL_UPDATE,FXFileList::ID_SET_PATTERN,FXFileList::onUpdSetPattern),
  FXMAPFUNC(SEL_UPDATE,FXFileList::ID_SET_DIRECTORY,FXFileList::onUpdSetDirectory),
  };


// Object implementation
FXIMPLEMENT(FXFileList,FXIconList,FXFileListMap,ARRAYNUMBER(FXFileListMap))


// File List
FXFileList::FXFileList(FXComposite *p,FXObject* tgt,FXSelector sel,FXuint opts,FXint x,FXint y,FXint w,FXint h):
  FXIconList(p,tgt,sel,opts,x,y,w,h),directory(defpath),pattern("*"){
  header->addItemLast("Name",NULL,200,this,ID_SORT_BY_NAME);
  header->addItemLast("Type",NULL,100,this,ID_SORT_BY_TYPE);
  header->addItemLast("Size",NULL,60,this,ID_SORT_BY_SIZE);
  header->addItemLast("Modified Date",NULL,150,this,ID_SORT_BY_TIME);
  header->addItemLast("User",NULL,50,this,ID_SORT_BY_USER);
  header->addItemLast("Group",NULL,50,this,ID_SORT_BY_GROUP);
  header->addItemLast("Attributes",NULL,100);
  refresh=NULL;
  list=NULL;
  timestamp=0;
  big_folder=new FXGIFIcon(getApp(),bigfolder);
  mini_folder=new FXGIFIcon(getApp(),minifolder);
  big_doc=new FXGIFIcon(getApp(),bigdoc);
  mini_doc=new FXGIFIcon(getApp(),minidoc);
  big_app=new FXGIFIcon(getApp(),bigapp);
  mini_app=new FXGIFIcon(getApp(),miniapp);
  sortfunc=cmpFName;
  matchmode=FILEMATCH_FILE_NAME|FILEMATCH_PERIOD|FILEMATCH_NOESCAPE;
  }


// Starts the timer
void FXFileList::create(){
  FXIconList::create();
  refresh=getApp()->addTimeout(1,this,1000);
  big_folder->create();
  mini_folder->create();
  big_doc->create();
  mini_doc->create();
  big_app->create();
  mini_app->create();
  listDirectory();
  sortDirectory();
  }


// Destroy zaps the icons
void FXFileList::destroy(){
  big_folder->destroy();
  mini_folder->destroy();
  big_doc->destroy();
  mini_doc->destroy();
  big_app->destroy();
  mini_app->destroy();  
  FXIconList::destroy();
  }


// Create item
FXIconItem* FXFileList::createItem(){ return (FXIconItem*) new FXFileItem; }


// Get file name from item
FXString FXFileList::getItemFileName(FXIconItem* item) const {
  if(!item){ fxerror("%s::getItemFileName: item is NULL.\n",getClassName()); }
  return FXString(item->label.text(),'\t',0);
  }



// Somebody wants our selection
long FXFileList::onSelectionRequest(FXObject* sender,FXSelector sel,void* ptr){
  FXchar name[MAXPATHLEN+1],*p;
  FXuchar *data; 
//fprintf(stderr,"%s::onSelectionRequest %x\n",getClassName(),this);
  
  // Try handle through base class first
  if(FXIconList::onSelectionRequest(sender,sel,ptr)) return 1;
  
  // Otherwise (most likely) its the string from this text we return
  // Strictly speaking, we should return ALL selected items, not just the current
  // one....
  if(currentitem && isItemSelected(currentitem)){
    if(getDNDType()==XA_STRING){
      FXCALLOC(&data,FXuchar,MAXPATHLEN+1);
      strcpy(name,currentitem->label.text());
      if((p=strchr(name,'\t'))) *p=0;
      fxpathname((FXchar*)data,directory.text(),name);
      setDNDData(XA_STRING,data,strlen((FXchar*)data));
      }
    }
  return 0;
  }


// Set current directory from dir part of filename
long FXFileList::onCmdSetStringValue(FXObject*,FXSelector,void* ptr){
  FXchar dir[MAXPATHLEN+1];
  if(ptr){ 
    fxdirpart(dir,*((FXString*)ptr));
    setDirectory(dir);
    }
  return 1;
  }


// Get current file name
long FXFileList::onCmdGetStringValue(FXObject*,FXSelector,void* ptr){
  FXchar name[2048],dir[MAXPATHLEN+1],*p;
  if(ptr){ 
    name[0]=0;
    if(currentitem){
      strcpy(name,getItemText(currentitem));
      if((p=strchr(name,'\t'))) *p=0;
      }
    fxpathname(dir,getDirectory(),name);
    *((FXString*)ptr) = name; 
    }
  return 1;
  }


// Move up one level
long FXFileList::onCmdDirectoryUp(FXObject*,FXSelector,void* ptr){
  FXchar dir[MAXPATHLEN+1];
  setDirectory(fxupdir(dir,directory.text()));
  return 1;
  }


// Determine if we can still go up more
long FXFileList::onUpdDirectoryUp(FXObject* sender,FXSelector,void* ptr){
  FXuint msg = fxistopdir(directory.text()) ? ID_DISABLE : ID_ENABLE;
  sender->handle(this,MKUINT(msg,SEL_COMMAND),ptr);
  return 1;
  }


// Create new directory
long FXFileList::onCmdDirectoryNew(FXObject*,FXSelector,void*){
  return 1;
  }


// Currently not yet implemented
long FXFileList::onUpdDirectoryNew(FXObject* sender,FXSelector,void* ptr){
  FXuint msg=ID_DISABLE;
  sender->handle(this,MKUINT(msg,SEL_COMMAND),ptr);
  return 1;
  }


// Change pattern
long FXFileList::onCmdSetPattern(FXObject*,FXSelector,void* ptr){
  if(!ptr) return 0;
  setPattern((const char*)ptr);
  return 1;
  }


// Update pattern
long FXFileList::onUpdSetPattern(FXObject* sender,FXSelector,void* ptr){
  sender->handle(this,MKUINT(FXWindow::ID_SETVALUE,SEL_COMMAND),(void*)pattern.text());
  return 1;
  }


// Change directory
long FXFileList::onCmdSetDirectory(FXObject*,FXSelector,void* ptr){
  if(!ptr) return 0;
  setDirectory((const char*)ptr);
  return 1;
  }


// Update directory
long FXFileList::onUpdSetDirectory(FXObject* sender,FXSelector,void* ptr){
  sender->handle(this,MKUINT(FXWindow::ID_SETVALUE,SEL_COMMAND),(void*)directory.text());
  return 1;
  }


// Sort by name
long FXFileList::onCmdSortByName(FXObject*,FXSelector,void*){
  sortfunc=(sortfunc==cmpFName)?cmpRName:cmpFName;
  sortItems();
  return 1;
  }


// Update sender
long FXFileList::onUpdSortByName(FXObject* sender,FXSelector,void* ptr){
  FXuint msg=(sortfunc==cmpFName || sortfunc==cmpRName)?ID_CHECK:ID_UNCHECK;
  sender->handle(this,MKUINT(msg,SEL_COMMAND),ptr);
  return 1;
  }


// Sort by type
long FXFileList::onCmdSortByType(FXObject*,FXSelector,void*){
  sortfunc=(sortfunc==cmpFType)?cmpRType:cmpFType;
  sortItems();
  return 1;
  }


// Update sender
long FXFileList::onUpdSortByType(FXObject* sender,FXSelector,void* ptr){
  FXuint msg=(sortfunc==cmpFType || sortfunc==cmpRType)?ID_CHECK:ID_UNCHECK;
  sender->handle(this,MKUINT(msg,SEL_COMMAND),ptr);
  return 1;
  }


// Sort by size
long FXFileList::onCmdSortBySize(FXObject*,FXSelector,void*){
  sortfunc=(sortfunc==cmpFSize)?cmpRSize:cmpFSize;
  sortItems();
  return 1;
  }


// Update sender
long FXFileList::onUpdSortBySize(FXObject* sender,FXSelector,void* ptr){
  FXuint msg=(sortfunc==cmpFSize || sortfunc==cmpRSize)?ID_CHECK:ID_UNCHECK;
  sender->handle(this,MKUINT(msg,SEL_COMMAND),ptr);
  return 1;
  }


// Sort by time
long FXFileList::onCmdSortByTime(FXObject*,FXSelector,void*){
  sortfunc=(sortfunc==cmpFTime)?cmpRTime:cmpFTime;
  sortItems();
  return 1;
  }


// Update sender
long FXFileList::onUpdSortByTime(FXObject* sender,FXSelector,void* ptr){
  FXuint msg=(sortfunc==cmpFTime || sortfunc==cmpRTime)?ID_CHECK:ID_UNCHECK;
  sender->handle(this,MKUINT(msg,SEL_COMMAND),ptr);
  return 1;
  }


// Sort by user
long FXFileList::onCmdSortByUser(FXObject*,FXSelector,void*){
  sortfunc=(sortfunc==cmpFUser)?cmpRUser:cmpFUser;
  sortItems();
  return 1;
  }


// Update sender
long FXFileList::onUpdSortByUser(FXObject* sender,FXSelector,void* ptr){
  FXuint msg=(sortfunc==cmpFUser || sortfunc==cmpRUser)?ID_CHECK:ID_UNCHECK;
  sender->handle(this,MKUINT(msg,SEL_COMMAND),ptr);
  return 1;
  }


// Sort by group
long FXFileList::onCmdSortByGroup(FXObject*,FXSelector,void*){
  sortfunc=(sortfunc==cmpFGroup)?cmpRGroup:cmpFGroup;
  sortItems();
  return 1;
  }


// Update sender
long FXFileList::onUpdSortByGroup(FXObject* sender,FXSelector,void* ptr){
  FXuint msg=(sortfunc==cmpFGroup || sortfunc==cmpRGroup)?ID_CHECK:ID_UNCHECK;
  sender->handle(this,MKUINT(msg,SEL_COMMAND),ptr);
  return 1;
  }


// Reverse sort order
long FXFileList::onCmdSortReverse(FXObject*,FXSelector,void*){
  sortItems();
  return 1;
  }


// Update sender
long FXFileList::onUpdSortReverse(FXObject* sender,FXSelector,void* ptr){
  FXuint msg=ID_UNCHECK;
  if(sortfunc==cmpRName) msg=ID_CHECK;
  if(sortfunc==cmpRType) msg=ID_CHECK;
  if(sortfunc==cmpRSize) msg=ID_CHECK;
  if(sortfunc==cmpRTime) msg=ID_CHECK;
  if(sortfunc==cmpRUser) msg=ID_CHECK;
  if(sortfunc==cmpRGroup) msg=ID_CHECK;
  sender->handle(this,MKUINT(msg,SEL_COMMAND),ptr);
  return 1;
  }


/*******************************************************************************/

// Compare file names
FXbool FXFileList::cmpFName(const FXItem* a,const FXItem* b){
  const char *p,*q;
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){ 
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  p=((FXFileItem*)a)->label.text();
  q=((FXFileItem*)b)->label.text();
  while(1){
    if(*p > *q) return 1;
    if(*p < *q) return 0;
    if(*p=='\t') return 0;
    p++;
    q++;
    }
  return 0;
  }


// Compare file types
FXbool FXFileList::cmpFType(const FXItem* a,const FXItem* b){
  const char *p,*q;
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  p=strchr(((FXFileItem*)a)->label.text(),'\t')+1;
  q=strchr(((FXFileItem*)b)->label.text(),'\t')+1;
  while(1){
    if(*p > *q) return 1;
    if(*p < *q) return 0;
    if(*p=='\t') return 0;
    p++;
    q++;
    }
  return 0;
  }


// Compare file size
FXbool FXFileList::cmpFSize(const FXItem* a,const FXItem* b){
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  return ((long)((FXFileItem*)a)->size) > ((long)((FXFileItem*)b)->size);
  }


// Compare file time
FXbool FXFileList::cmpFTime(const FXItem* a,const FXItem* b){
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  return ((long)((FXFileItem*)a)->date) > ((long)((FXFileItem*)b)->date);
  }


// Compare file user
FXbool FXFileList::cmpFUser(const FXItem* a,const FXItem* b){
  const char *p,*q; int i;
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  for(p=((FXFileItem*)a)->label.text(),i=4; *p && i; i-=(*p++=='\t')); 
  for(q=((FXFileItem*)b)->label.text(),i=4; *q && i; i-=(*q++=='\t')); 
  while(1){
    if(*p > *q) return 1;
    if(*p < *q) return 0;
    if(*p=='\t') return 0;
    p++;
    q++;
    }
  return 0;
  }


// Compare file group
FXbool FXFileList::cmpFGroup(const FXItem* a,const FXItem* b){
  const char *p,*q; int i;
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  for(p=((FXFileItem*)a)->label.text(),i=5; *p && i; i-=(*p++=='\t')); 
  for(q=((FXFileItem*)b)->label.text(),i=5; *q && i; i-=(*q++=='\t')); 
  while(1){
    if(*p > *q) return 1;
    if(*p < *q) return 0;
    if(*p=='\t') return 0;
    p++;
    q++;
    }
  return 0;
  }

// Reversed compare file name
FXbool FXFileList::cmpRName(const FXItem* a,const FXItem* b){ 
  const char *p,*q;
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  p=((FXFileItem*)a)->label.text();
  q=((FXFileItem*)b)->label.text();
  while(1){
    if(*p < *q) return 1;
    if(*p > *q) return 0;
    if(*p=='\t') return 0;
    p++;
    q++;
    }
  return 0;
  }


// Reversed compare file type
FXbool FXFileList::cmpRType(const FXItem* a,const FXItem* b){ 
  const char *p,*q;
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  p=strchr(((FXFileItem*)a)->label.text(),'\t')+1;
  q=strchr(((FXFileItem*)b)->label.text(),'\t')+1;
  while(1){
    if(*p < *q) return 1;
    if(*p > *q) return 0;
    if(*p=='\t') return 0;
    p++;
    q++;
    }
  return 0;
  }


// Reversed compare file size
FXbool FXFileList::cmpRSize(const FXItem* a,const FXItem* b){ 
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  return ((long)((FXFileItem*)a)->size) < ((long)((FXFileItem*)b)->size);
  }


// Reversed compare file time
FXbool FXFileList::cmpRTime(const FXItem* a,const FXItem* b){ 
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  return ((long)((FXFileItem*)a)->date) < ((long)((FXFileItem*)b)->date);
  }


// Reversed compare file user
FXbool FXFileList::cmpRUser(const FXItem* a,const FXItem* b){ 
  const char *p,*q; int i;
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  for(p=((FXFileItem*)a)->label.text(),i=4; *p && i; i-=(*p++=='\t')); 
  for(q=((FXFileItem*)b)->label.text(),i=4; *q && i; i-=(*q++=='\t')); 
  while(1){
    if(*p < *q) return 1;
    if(*p > *q) return 0;
    if(*p=='\t') return 0;
    p++;
    q++;
    }
  return 0; 
  }


// Reversed compare file group
FXbool FXFileList::cmpRGroup(const FXItem* a,const FXItem* b){ 
  const char *p,*q; int i;
  if((((FXFileItem*)a)->state&FILEITEM_DIRECTORY) != (((FXFileItem*)b)->state&FILEITEM_DIRECTORY)){
    return (((FXFileItem*)a)->state&FILEITEM_DIRECTORY)==0;
    }
  for(p=((FXFileItem*)a)->label.text(),i=5; *p && i; i-=(*p++=='\t')); 
  for(q=((FXFileItem*)b)->label.text(),i=5; *q && i; i-=(*q++=='\t')); 
  while(1){
    if(*p < *q) return 1;
    if(*p > *q) return 0;
    if(*p=='\t') return 0;
    p++;
    q++;
    }
  return 0; 
  }


/*******************************************************************************/


// Got refresh timeout
long FXFileList::onRefresh(FXObject*,FXSelector,void*){
  FXchar dir[MAXPATHLEN+1];
  struct stat info;
  if(stat(directory.text(),&info)==0){
    if(timestamp!=info.st_mtime){
      listDirectory();
      sortDirectory();
      recalc();
      }
    }
  else{
    setDirectory(fxupdir(dir,directory.text()));
//fprintf(stderr,"%s::onRefresh: %s\n",getClassName(),directory.text());
    }
  refresh=getApp()->addTimeout(REFRESHINTERVAL,this,1000);
  return 1;
  }


// Set directory being displayed
void FXFileList::setDirectory(const FXchar* path){
  FXchar abspath[MAXPATHLEN+1];
  if(path==NULL || path[0]==0){ fxerror("%s::setDirectory: empty path specified.\n",getClassName()); }
  if(directory!=path){
    directory=fxabspath(abspath,NULL,path);
    if(id()){
      wipeDirectory();
      listDirectory();
      sortDirectory();
      recalc();
      }
    }
  }


// Set the pattern to filter
void FXFileList::setPattern(const FXchar* ptrn){
  if(ptrn==NULL){ fxerror("%s::setPattern: empty pattern specified.\n",getClassName()); }
  if(pattern!=ptrn){
    pattern=ptrn;
    timestamp=0;
    if(id()){
      listDirectory();
      sortDirectory();
      recalc();
      }
    }
  }


// Change file match mode
void FXFileList::setMatchMode(FXuint mode){
  if(matchmode!=mode){
    matchmode=mode;
    timestamp=0;
    listDirectory();
    sortDirectory();
    recalc();
    }
  }


// Wipe directory
FXbool FXFileList::wipeDirectory(){
  register FXFileItem *item;
  if(!list) return FALSE;
  while(list){
    item=list;
    list=list->inext;
    delete item;
    }
  firstitem=NULL;
  lastitem=NULL;
  currentitem=NULL;
  anchoritem=NULL;
  timestamp=0;
  return TRUE;
  }


// Sort directory 
FXbool FXFileList::sortDirectory(){
  if(!sortfunc) return FALSE;
  FXItem *f=(FXItem*)firstitem;
  FXItem *l=(FXItem*)lastitem;
  fxsort((FXItem*&)firstitem,(FXItem*&)lastitem,f,l,sortfunc,getNumItems());
  return TRUE;
  }


// Compare till '\t'
static FXbool fileequal(const FXchar* a,const FXchar* b){
  while(*a == *b){ if(*a=='\t') return TRUE; a++; b++; }
  return FALSE;
  }


// List directory
FXbool FXFileList::listDirectory(){
  FXbool changed=FALSE;
  char pathname[MAXPATHLEN],*pathtail;
  char grpid[64],usrid[64],atts[16],mod[32];
  FXFileItem *after,*before,*item,*it;
  FXIcon *big,*mini;
  struct stat info;
  char fileinfo[2048];
  char *filetype;
  char *name;
#ifndef WIN32
  struct dirent *dp;
  DIR *dirp;
  int islink;
#else
  WIN32_FIND_DATA ffData;
  HANDLE hFindFile;
  DWORD dwBinaryType;
#endif

#ifndef WIN32
  // Get time stamp
  if(stat(directory.text(),&info)!=0) return FALSE;

  // Still valid
  if(timestamp==info.st_mtime) return FALSE;

  timestamp=info.st_mtime;

  // Get directory stream pointer
  dirp=opendir(directory.text());
  if(!dirp) return FALSE;
    
  // Set path to lstat with
  strcpy(pathname,directory.text());
  pathtail=pathname+strlen(pathname)-1;
  if(*pathtail!=PATHSEP) *++pathtail=PATHSEP;
  ++pathtail;

  // Build new insert-order list
  after=NULL;
  before=list;
  list=NULL;

  // Loop over directory entries
  while((dp=readdir(dirp))!=NULL){
    name=dp->d_name;

    // A dot special file?
    if(name[0]=='.' && (name[1]==0 || (name[1]=='.' && name[2]==0))) continue;

    // Build full pathname
    strcpy(pathtail,name);

    // Get file/link info
    if(lstat(pathname,&info)!=0) continue;

    // If its a link, get the file info
    islink=S_ISLNK(info.st_mode);
    if(islink && stat(pathname,&info)!=0) continue;

    // Is it a directory or does it match the pattern?
    if(!S_ISDIR(info.st_mode) && !fxfilematch(pattern.text(),name,matchmode)) continue;
    
    // Obtain user name
    fxgetusername(usrid,info.st_uid);

    // Obtain group name
    fxgetgroupname(grpid,info.st_gid);

    // Permissions
    fxgetpermissions(atts,info.st_mode);

    // Mod time
    strncpy(mod,ctime(&info.st_mtime)+4,20);
    mod[20]=0;

    // Determine file type
    big=big_doc;
    mini=mini_doc;
    filetype="Document";
    if(S_ISDIR(info.st_mode)){
      big=big_folder;
      mini=mini_folder;
      filetype="Folder";
      }
    else if(info.st_mode&(S_IXUSR|S_IXGRP|S_IXOTH)){
      big=big_app;
      mini=mini_app;
      filetype="Application";
      }
    else if(fxfilematch("*.ps",name))
      filetype="PostScript";
    else if(fxfilematch("*.cc",name))
      filetype="C++ Source File";
    else if(fxfilematch("*.cpp",name))
      filetype="C++ Source File";
    else if(fxfilematch("*.h",name))
      filetype="C Header File";
    else if(fxfilematch("*.c",name))
      filetype="C Source File";
    else if(fxfilematch("*.o",name))
      filetype="Object Code";
    else if(fxfilematch("*.tar",name))
      filetype="Tar File";
    else if(fxfilematch("*.tar.gz",name))
      filetype="Tarz File";
    else if(fxfilematch("*.gif",name))
      filetype="GIF Image";
    else if(fxfilematch("*.jpg",name))
      filetype="JPEG Image";
    else if(fxfilematch("*.rgb",name))
      filetype="RGB Image";
    else if(fxfilematch("*.xpm",name))
      filetype="XPM Image";
    else if(fxfilematch("*.bmp",name))
      filetype="BMP Image";
    else if(fxfilematch("*.html",name))
      filetype="HTML Document";
    else if(fxfilematch("README",name))
      filetype="README";
    else if(fxfilematch("Makefile",name))
      filetype="Makefile";
    else if(fxfilematch("*.DTF",name))
      filetype="CFDRC DTF File";

    // Build File Info
    sprintf(fileinfo,"%s\t%s\t%d\t%s\t%s\t%s\t%s",name,filetype,info.st_size,mod,usrid,grpid,atts);

    // Find place to add it; if found, zap all between 
    // before and item as they must have disappeared!!
    for(item=before; item; item=item->inext){
      if(fileequal(item->label.text(),fileinfo)){
        while(before!=item){
          it=before;
          before=before->inext;
          if(it->prev) it->prev->next=it->next; else firstitem=it->next;
          if(it->next) it->next->prev=it->prev; else lastitem=it->prev;
          if(currentitem==it) currentitem=NULL;
          if(anchoritem==it) anchoritem=NULL;
          changed=TRUE;
          delete it;
          }
        before=item->inext;
        if(before) before->iprev=NULL;
        item->inext=NULL;
        item->iprev=NULL;
        goto fnd;
        }
      }
    
    // Not found, add new item
    item=(FXFileItem*)createItem();
    item->prev=lastitem;
    item->next=NULL;
    item->iprev=NULL;
    item->inext=NULL;
    item->state=0;
    if(lastitem) item->prev->next=item; else firstitem=item;
    lastitem=item;
    changed=TRUE;
    
    // Next gets hung after this one
fnd:item->iprev=after;
    if(after) after->inext=item; else list=item;

    // Update item with the new info
    item->label=fileinfo;
    item->icon=big;
    item->miniIcon=mini;
    if(info.st_mode&(S_IXUSR|S_IXGRP|S_IXOTH)) item->state|=FILEITEM_EXECUTABLE; else item->state&=~FILEITEM_EXECUTABLE;
    if(S_ISDIR(info.st_mode)) item->state|=FILEITEM_DIRECTORY; else item->state&=~FILEITEM_DIRECTORY;
    if(S_ISLNK(info.st_mode)) item->state|=FILEITEM_SYMLINK; else item->state&=~FILEITEM_SYMLINK;
    if(S_ISCHR(info.st_mode)) item->state|=FILEITEM_CHARDEV; else item->state&=~FILEITEM_CHARDEV;
    if(S_ISBLK(info.st_mode)) item->state|=FILEITEM_BLOCKDEV; else item->state&=~FILEITEM_BLOCKDEV;
    if(S_ISFIFO(info.st_mode)) item->state|=FILEITEM_FIFO; else item->state&=~FILEITEM_FIFO;
    if(S_ISSOCK(info.st_mode)) item->state|=FILEITEM_SOCK; else item->state&=~FILEITEM_SOCK;
    item->size=info.st_size;
    item->date=info.st_mtime;
    
    // If info changed...
    // Next one goes after this one
    after=item;
    }
    
  // Wipe items remaining in list:- they have disappeared!!
  while(before){
    it=before;
    before=before->inext;
    if(it->prev) it->prev->next=it->next; else firstitem=it->next;
    if(it->next) it->next->prev=it->prev; else lastitem=it->prev;
    if(currentitem==it) currentitem=NULL;
    if(anchoritem==it) anchoritem=NULL;
    changed=TRUE;
    delete it;
    }
  
  // Close and repaint
  closedir(dirp);

#else

  // Get time stamp
  if(stat(directory.text(),&info)!=0) return FALSE;

  // Still valid?
  if(timestamp==info.st_mtime) return FALSE;

  // Update the timestamp
  timestamp=info.st_mtime;

  // Set path to lstat with
  strcpy(pathname,directory.text());
  pathtail=pathname+strlen(pathname)-1;
  if(*pathtail!=PATHSEP) *++pathtail=PATHSEP;
  ++pathtail;

  // Get file find handle and first file's info
  strcpy(pathtail,pattern.text());
  hFindFile=FindFirstFile(pathname,&ffData);
  if(hFindFile==INVALID_HANDLE_VALUE) return FALSE;
  
  // Build new insert order list
  after=NULL;
  before=list;
  list=NULL;

  // Loop over files:-
  // Note: We already have the first file's info in ffData
  // when this loop begins. So the call to FindNextFile() is
  // postponed to the end of the loop.
  do{
    // Grab the file name
    name=ffData.cFileName;

    // A dot special file?
    if(!strcmp(name, ".") || !strcmp(name, "..")) continue;

    // A hidden file?
    if(ffData.dwFileAttributes&FILE_ATTRIBUTE_HIDDEN) continue;

    // Grab this stuff
    if(stat(name, &info)!=0) continue;

    // Obtain user name (no Win95 equivalent?)
    fxgetusername(usrid,info.st_uid);

    // Obtain group name (no Win95 equivalent?)
    fxgetgroupname(grpid,info.st_gid);

    // Permissions
    strcpy(atts, "-rwxrwxrwx");

    // Is it a directory?
    if(ffData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY)
      atts[0]='d';

    // Check if file is read-only
    if(ffData.dwFileAttributes&FILE_ATTRIBUTE_READONLY){
      atts[2]='-'; atts[5]='-'; atts[8]='-';
      }

    // Is it an executable file?
    if(!GetBinaryType(pathname, &dwBinaryType)){
      atts[3]='-'; atts[6]='-'; atts[9]='-';
      }

    // Mod time
    strncpy(mod,ctime(&info.st_mtime)+4,20);
    mod[20]=0;

    // Determine file type
    // On Win95/NT we should be able to get this from the Registry...
    big=big_doc;
    mini=mini_doc;
    filetype="File";
    if(ffData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY){
      big=big_folder;
      mini=mini_folder;
      filetype="File Folder";
      }
    else if(GetBinaryType(pathname,&dwBinaryType)){
      big=big_app;
      mini=mini_app;
      filetype="Application";
      }
    else if(fxfilematch("*.ps",name))
      filetype="PostScript";
    else if(fxfilematch("*.cc",name))
      filetype="C++ Source File";
    else if(fxfilematch("*.cpp",name))
      filetype="C++ Source File";
    else if(fxfilematch("*.h",name))
      filetype="C Header File";
    else if(fxfilematch("*.c",name))
      filetype="C Source File";
    else if(fxfilematch("*.o",name))
      filetype="Object Code";
    else if(fxfilematch("*.tar",name))
      filetype="Tar File";
    else if(fxfilematch("*.tar.gz",name))
      filetype="Tarz File";
    else if(fxfilematch("*.gif",name))
      filetype="GIF Image";
    else if(fxfilematch("*.jpg",name))
      filetype="JPEG Image";
    else if(fxfilematch("*.rgb",name))
      filetype="RGB Image";
    else if(fxfilematch("*.xpm",name))
      filetype="XPM Image";
    else if(fxfilematch("*.bmp",name))
      filetype="BMP Image";
    else if(fxfilematch("*.html",name))
      filetype="HTML Document";
    else if(fxfilematch("README",name))
      filetype="README";
    else if(fxfilematch("Makefile",name))
      filetype="Makefile";
    else if(fxfilematch("*.DTF",name))
      filetype="CFDRC DTF File";

    // Build fileinfo string
    sprintf(fileinfo, "%s\t%s\t%d\t%s\t%s\t%s\t%s",name,filetype,info.st_size,mod,usrid,grpid,atts);

    // Find place to add it
    item = 0;
    for(item=before; item; item=item->inext){
      if(fileequal(item->label.text(),fileinfo)){
        while(before!=item){
          it=before;
          before=before->inext;
          if(it->prev) it->prev->next=it->next; else firstitem=it->next;
          if(it->next) it->next->prev=it->prev; else lastitem=it->prev;
          if(currentitem==it) currentitem=NULL;
          if(anchoritem==it) anchoritem=NULL;
          changed=TRUE;
          delete it;
          }
        before=item->inext;
        if(before) before->iprev=NULL;
        item->inext=NULL;
        item->iprev=NULL;
        goto fnd;
        }
      }

    // Not found, so add a new item
    item=(FXFileItem*)createItem();
    item->prev=lastitem;
    item->next=NULL;
    item->iprev=NULL;
    item->inext=NULL;
    item->state=0;
    if(lastitem) item->prev->next=item; else firstitem=item;
    lastitem=item;
    changed=TRUE;

    // Next gets hung after this one
fnd:item->iprev=after;
    if(after) after->inext=item; else list=item;

    // Update item with the new info
    item->label=fileinfo;
    item->icon=big;
    item->miniIcon=mini;
    item->size=info.st_size;
    item->date=0;
    if(ffData.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY) item->state|=FILEITEM_DIRECTORY;
    item->size=ffData.nFileSizeLow;
    //item->size=info.st_size;
    item->date=info.st_mtime;
    // Time in 100ns units since 1601. Perhaps this was to run Fenestra MDCI
    // on then state-of-the-art water-powered mechanical calculating engines.
    //item->date=ffData.ftLastWriteTime.dwHighDateTime;	
    //item->date=ffData.ftLastWriteTime.dwLowDateTime;

    // If info changed...
    // Next one goes after this one
    after=item;
    } 
  while(FindNextFile(hFindFile,&ffData));


  // Wipe items remaining in list:- they have disappeared!!
  while(before){
    it=before;
    before=before->inext;
    if(it->prev) it->prev->next=it->next; else firstitem=it->next;
    if(it->next) it->next->prev=it->prev; else lastitem=it->prev;
    if(currentitem==it) currentitem=NULL;
    if(anchoritem==it) anchoritem=NULL;
    changed=TRUE;
    delete it;
    }

  // Close the file find handle and repaint
  FindClose(hFindFile);
#endif
  return changed;
  }

      

// Is directory
FXbool FXFileList::isDirectory(const FXIconItem* item) const {
  if(item==NULL){ fxerror("%s::getItemData: item is NULL.\n",getClassName()); }
  return (item->state&FILEITEM_DIRECTORY)!=0;
  }


// Is file
FXbool FXFileList::isFile(const FXIconItem* item) const {
  if(item==NULL){ fxerror("%s::getItemData: item is NULL.\n",getClassName()); }
  return (item->state&(FILEITEM_DIRECTORY|FILEITEM_CHARDEV|FILEITEM_BLOCKDEV|FILEITEM_FIFO|FILEITEM_SOCK))==0;
  }


// Cleanup
FXFileList::~FXFileList(){
  if(refresh) getApp()->removeTimeout(refresh);
  delete big_folder;
  delete mini_folder;
  delete big_doc;
  delete mini_doc;
  delete big_app;
  delete mini_app;
  big_folder=(FXGIFIcon*)-1;
  mini_folder=(FXGIFIcon*)-1;
  big_doc=(FXGIFIcon*)-1;
  mini_doc=(FXGIFIcon*)-1;
  big_app=(FXGIFIcon*)-1;
  mini_app=(FXGIFIcon*)-1;
  refresh=(FXTimer*)-1;
  }


