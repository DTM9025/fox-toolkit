<html>
<head>
<link rel="stylesheet" href="page.css" type="text/css">
<title>Documentation: The Application Class</title>
</head>
<body bgcolor=#ffffff link=#990033 vlink=#990033 alink=#990033 text=#000000>

<!---- TOPIC TITLE WITH LOGO--->
<table border=0 cellpadding= cellspacing=2 width=100% ><tr><td><a href='http://www.fox-toolkit.org' target=_top><img src='art/foxlogo_small.jpg' border=0></a></td><td width=100% valign=bottom id="HEADLINE"><b>
Documentation: The Application Class  <A href='app.html' target="_top" align=left><font  size=-2>[Remove Frame]</font></a>
<br><img src='art/line.gif' width=100% height=1></b></td></tr></table>
</p>
<!--- TOPIC TITLE WITH LOGO --->


<!--- TOPIC TITLE -->
<p>
<table width=100% cellpadding=0 cellspacing=2><tr><td width=100% valign=bottom id=HEADLINE><b>
The FXApp Class
<br><img src='art/line.gif' width=100% height=1></b></td></tr></table>
</p>
<!--- TOPIC TITLE -->
<ul>
  <p>The application object manages the message queue,
  timers, chores, GUI updating, and other system facilities. Each FOX
  application will have exactly one application instance.
  Every FOX application will start by constructing
  one FXApp object prior to building the GUI.&nbsp; Usually, the FXApp object
  is the last object to be deleted as well.</p>

  <p>Using the code below, the application object will be constructed on the stack and hence is automatically destroyed when
  the program terminates.&nbsp; Also, when the application object is
  destroyed, all the windows and other resources it knows about are destroyed
  as well.</p>

<pre>
int main(int argc,char *argv[]){

  // Make application
  FXApp application("ApplicationName","VendorName");


  // Open display
  application.init(argc,argv);


  // Make window
  MainWindow* mainwindow=new MainWindow(&application);


  // Create it
  application.create();


  // Show Window
  mainwindow->show();


  // Run
  return application.run();
  }
</pre>

  <p>In the first line of code above, an application
  object is constructed.&nbsp; The constructor has two parameters, the application
  name, and the vendor name.&nbsp; The application name and vendor name are
  used to determine the applications registry settings.</p>

  <p>The next line of code initializes the application
  object, passing in the command line arguments of the process.&nbsp; The
  application object parses its own arguments and removes them, but leaves
  the remaining arguments alone.</p>

  <p>The next line creates a toplevel window, passing in a pointer to the application object.</p>
  <p>The call to the application object's create() function realizes the entire widget tree, i.e. creates the necessary resources
  in the system (X Server or Windows GDI), to turn what was up till that
  point a collection of C++ data structures into a real-life application
  which is able to receive events and draw on the screen.</p>
  <p>The final call to run() starts the toplevel event loop. A typical application will not return from this loop until the user closes the application.</p>

</ul>


<!--- TOPIC TITLE -->
<p>
<table width=100% cellpadding=0 cellspacing=2><tr><td width=100% valign=bottom id=HEADLINE><b>
Event Loops
<br><img src='art/line.gif' width=100% height=1></b></td></tr></table>
</p>
<!--- TOPIC TITLE -->
<ul>
  <p>Most GUI applications have something called an <b>event loop</b> or <b>message loop</b>.&nbsp;
  Unlike batch-oriented programs which read a datafile, perform some processing, and then produce an
  output file, a GUI driven application spends almost all its time in an event loop, waiting
  for user input, determining where that input came from, and then dispatching
  it to the proper function to perform some processing. Unlike batch oriented programs, these functions are typically very short, and mostly take
  only very little time to execute, and so the user is in complete control of the application
  most of the time. The events a GUI program processes can be of different types:</p>

  <ul>
  <li>Keyboard input;</li>
  <li>Mouse movements;</li>
  <li>Mouse buttons;</li>
  <li>Inputs from other sources (e.g. network sockets, timers, signals, and so on);</li>
  <li>Changes in selection and clipboard ownership;</li>
  <li>Drag and drop events;</li>
  <li>Window repaint events;</li>
  <li>And other things which can happen to a window.</li>
  </ul>

  <p>The application object is solely responsible for coordinating all these events and dispatching them to the proper destination where they are handled.</p>
  <p>FXApp performs delayed repaints on windows, i.e. almost all events are prioritized over repaint events so as to delay expensive redrawing as much as possible.&nbsp; Because of this, repainting can never
  fall behind more than one repaint, and needless repaints are avoided as
  much as possible.&nbsp; Also FXApp combines repaint rectangles so as to
  minimize the video card hardware setup and teardown time relative to the
  number of pixels drawn.</p>
</ul>


<!--- TOPIC TITLE -->
<p>
<table width=100% cellpadding=0 cellspacing=2><tr><td width=100% valign=bottom id=HEADLINE><b>
Event Queues
<br><img src='art/line.gif' width=100% height=1></b></td></tr></table>
</p>
<!--- TOPIC TITLE -->
<ul>
  <p>Certain devices, such as a moving mouse, can generate
  events faster than some programs can process them.&nbsp; To prevent losing
  events, events are commonly queued up, so programs can catch up as fast
  as they can. Likewise, the drawing commands a GUI program
  generates as its trying to draw buttons and other controls on the screen
  are also queued up, so that the X server (or GDI on Windows) can take its
  time to catch up.</p>

  <p>Finally, the X server may have its own event queue
  and drawing queue, making for a total of <b>four queues</b>.&nbsp; All
  these queues allow for much faster performance of applications, as bigger
  chunks of data can be transmitted between the application and the X server,
  and fewer context switches of video card and cpu hardware are needed.</p>

  <p>From the point of programming in FOX, the existence
  of these queues is for the most part hidden, but in a few cases some special
  functions are available that you may need to call:</p>

  <ul>
  <b><u>FXApp::flush(sync)</u></b>
  <p>This function flushes the output queue, i.e. the
  commands which have been already performed are pushed to the X server,
  where they are executed.
  If we want to make sure that the display shows
  the correct picture, however, just pushing the commands to the X server
  is not enough:- sometimes we need to make sure that these commands
  have been executed before we continue!
  When a TRUE is passed for the sync parameter,
  the X server is forced to execute these commands.</p>
  </ul>

<p>Sometimes, we want to check if there are any events,
but continue to do some processing if no events are available.&nbsp; Under
normal circumstances, returning to the event loop will cause our process
to block until there are events; but if there is stuff we may want to do,
this is of course not desirable.&nbsp; We have just the right solution
for this problem:</p>

  <ul>
    <b><u>FXApp::peekEvent()</u></b>
    <p>This function will return TRUE if there are any
    events ready to process, and FALSE if there are none.&nbsp; The peekEvent()
    function can be used when we are doing a long calculation and we want to
    check if the user has hit the STOP button.</p>
  </ul>

</ul>

<!--- TOPIC TITLE -->
<p>
<table width=100% cellpadding=0 cellspacing=2><tr><td width=100% valign=bottom id=HEADLINE><b>
Types of Event Loops
<br><img src='art/line.gif' width=100% height=1></b></td></tr></table>
</p>
<!--- TOPIC TITLE -->
<ul>
  <p>There are several types of event loops supported,
  each of them is appropriate for certain sistuations; most commonly, application
  developers will however only call:</>

  <ul>
    <b><u>FXApp::run()</u></b>
    <p>This is the <i>top level </i>event loop, and it
    will only terminate when the application is ready to call it quits.
    When <b>run() </b>finally returns, its return value is the exit value passed
    to <b>stop()</b> earlier.</p>

    <b><u>FXApp::stop(code)</u></b>
    <p>This function terminates the top level event loop,
    but also terminates all nested event loops which have been directly or
    indirectly invoked from this top level loop.&nbsp; Each nested loop is
    terminated with a code of <b><i>zero (0),</i></b> but the top level
    event loop is terminated with the given <b><i>code</i></b>.</p>

    <b><u>FXApp::runOneEvent()</u></b>
    <p>As the name implies, this function reads and then
    processes <b><i>one (1) </i></b>single event, and then returns.&nbsp; It
    is primarily interesting to use in combination with <b>peekEvent(),</b>
    as <b>peekEvent() </b>returns TRUE if there is <i>at least one </i>event
    ready to be processed.
    <br>If there is no event ready, <b>runOneEvent()</b>
    will block until there is at least one event.</p>

    <b><u>FXApp::runUntil(condition)</u></b>
    <p>This function processes events until the variable
    <b>condition</b>, which is passed as a reference, becomes non-zero.</p>
  </ul>

  <p><b><i>Modal dialogs</i></b> are dialog panels which
  block interaction with the rest of the application until they are completed.&nbsp;
  For example, while trying to open a file, the application is unable to
  interact in other way with the user until some file is selected and loaded in.
  In FOX, the <i>only</i> difference between normal dialogs and modal dialogs is <i>how</i> they are run:- modal dialogs are
  run by calling:</p>

  <ul>
    <b><u>FXApp::runModalFor(window)</u></b>
    <p>This function runs a <i>nested or recursive invocation</i>
    of the event loop, i.e. it re-enters an event loop and processes events
    for a while, and returns only when stopModal() or stop() is called.
    As long as runModalFor() is running, user-input
    events to all other windows, except for window and its children, are being blocked:-
    no interaction with other windows is possible until runModalFor() returns. When it returns, it returns the value passed to the stopModal() function, or 0 if stop()
    is called to terminate the application.</p>

    <p>However, it is quite possible, and in fact common,
    that one modal dialog invokes another.&nbsp; In that case, only the most
    recently invoked dialog can be interacted with.</p>

    <b><u>FXApp::runModalWhileShown(window)</u></b>
    <p>The function<b> runModalWhileShown()</b> runs until either <b>stopModal()</b> is called or the specified window becomes
    hidden. This is of interest when running popup menus or other temporary
    windows.</p>

    <b><u>FXApp::stopModal(window,code)</u></b>
    <p>Calling stopModal() causes the modal event loop
    with the matching window to terminate with code.&nbsp; However, stopModal()
    also causes all modal event loops which are nested more deeply to terminate
    with code <b><i>zero (0).</i></b></p>

    <b><u>FXApp::isModal(window)</u></b>
    <p>This function returns TRUE if a modal loop is
    in effect for the given window.</p>
  </ul>

  <p>Modal dialogs are always run with runModalFor().
  Because it is so common to construct a dialog on the stack, run it modally,
  and then process the inputs thus obtained, there is a convenience member
  function <b>FXDialogBox::execute() </b>which calls <b>create(),</b> <b>show(),</b>
  and then <b>runModalFor() </b>in turn. The FXDialogBox also understands several messages,
  for example ID_ACCEPT, ID_CANCEL, and SEL_CLOSE which call stopModal()
  returning a code 1, 0, and 0 respectively. The return <b><i>code 0</i></b> for <b>FXDialogBox::execute()</b>
  should <b><i>never</i></b> cause any <b><i>action</i></b> to be performed
  as it is the code returned when the dialog box is cancelled or closed!!</p>
</ul>


<!--- TOPIC TITLE -->
<p>
<table width=100% cellpadding=0 cellspacing=2><tr><td width=100% valign=bottom id=HEADLINE><b>
GUI Updating
<br><img src='art/line.gif' width=100% height=1></b></td></tr></table>
</p>
<!--- TOPIC TITLE -->
<ul>
  <p>As has been discussed before, the event loop blocks
  when no events are available.&nbsp; Prior to blocking, all windows which
  have been marked as dirty are repainted.&nbsp; One other thing that happens
  just prior to blocking is the GUI update process, which periodically refreshes
  all widgets by interrogating the application state.&nbsp; Each GUI update
  takes only a little time, yet the total number of widgets may be large.
  The GUI update is peformed just prior to blocking, so at the time it is being performed there is really nothing else for the
  application process to do (or it would be doing it!). The GUI update is normally started by calling:</p>

  <ul>
    <b><u>FXApp::refresh()</u></b>
    <p>This function reschedules another GUI update to be performed in the future.</p>

    <b><u>FXApp::forceRefresh()</u></b>
    <p>Calling this function will cause an immediate
    GUI update pass to be performed.&nbsp; Unlike the normal GUI update, which
    takes place unobstrusively one and a time, prior to blocking, forceRefresh()
    will not return until all windows have been refreshed.
    It is therefore quite expensive, and should be
    used only when strictly necessary.</p>
  </ul>

  <p>The GUI update has no impact on the perceived
  speed of an application because between each pair of GUI updates performed,
  a check for events is performed.</p>
</ul>


<!--- TOPIC TITLE -->
<p>
<table width=100% cellpadding=0 cellspacing=2><tr><td width=100% valign=bottom id=HEADLINE><b>
Visuals
<br><img src='art/line.gif' width=100% height=1></b></td></tr></table>
</p>
<!--- TOPIC TITLE -->
<ul>
  <p>An FXVisual is a description of the pixel organization
  on the display. For example, some high-quality graphics cards can do 24
  bits per pixel; other graphics cards may be limited to 16, 15 bits per
  pixel, or even just 8 bits/pixel.&nbsp; FOX programs can even work on 4
  bit/pixel (VGA mode) and 1 bit/pixel (monochrome), although it wouldn't
  be as much fun!</p>
  <p>Besides depth (number of bits/pixel), there are
  also other characteristics which come into play describing the pixel organization,
  such as colormaps, and wether or not a colormap can be written or not,
  and the byte and bit organization.</p>
  <p>Colormaps are commonly used on 8-bit/pixel systems.&nbsp;
  Most hardware only supports one hardware colormap, and this must be shared
  among all programs on the display.&nbsp; Because legacy toolkits such as
  Motif do not deal with full colormaps very gracefully, FOX applications
  deliberately do not try to grab all 256 colors from the colormap, but only
  125 colors.&nbsp; Images and Icons are dithered to get the best possible
  rendering given the number of colors available.</p>
  <p>You can improve the look of your program quite
  easily, however, as the maximum number of colors which the default visual
  tries to allocate can be easily changed using a command line argyment;
  for example,&nbsp; <b>"myapp&nbsp; -maxcolors 256"</b> will start myapp
  in such a way as to attempt to acquire all 256 colors from the colormap.</p>
  <p>Because other programs may already be running,
  the desired gamut of colors may not be available.&nbsp; If the exact color
  can not be obtained, FOX will try to find the <i>closest color </i>available
  and use that.</p>
  <p>Normally, the FXVisual a window uses is copied
  from its parent.&nbsp; You can change this visual for each window, or you
  can call:</p>

  <ul>
    <b><u>FXApp::setDefaultVisual(visual)</u></b>
    <p>This function will change the default visual to
    be used for all toplevel windows; the child-windows will simply inherit
    the visual from their parent.</p>
  </ul>

  <p>Alternatively, the maximum number of colors can also
  be set via the registry, using the <b>maxcolors</b> key under <b>[SETTINGS]
  </b>any number less than or equal to 256 colors may be specified, FXVisual
  will determine the best gamut to pick from the allowable number of colors.</p>

</ul>


<!--- TOPIC TITLE -->
<p>
<table width=100% cellpadding=0 cellspacing=2><tr><td width=100% valign=bottom id=HEADLINE><b>
Wait Cursors
<br><img src='art/line.gif' width=100% height=1></b></td></tr></table>
</p>
<!--- TOPIC TITLE -->
<ul>
  <p>Sometimes, an application needs to undertake a
  long task, such as e.g. loading a big file.&nbsp; In such cases, it is
  good form to present the user with some feedback to indicate that the application
  may be temporarily unresponsive.&nbsp; Common ways to do this are progress
  bars and changing the cursor shape to a stopwatch, or hourglass, or something
  like that.FXApp supports this by means of the following
  functions:</p>

  <ul>
    <b><u>FXApp::beginWaitCursor()</u></b>
    <p>This will change the cursor shape for all windows
    to the stopwatch cursor, or the cursor designated by <b>setWaitCursor().&nbsp;
    </b>Calls to <b>beginWaitCursor() </b>and <b>endWaitCursor() </b>can be
    nested in a stack-like fashion, with only the first call to <b>beginWaitCursor()
    </b>and last call to <b>endWaitCursor() </b>actually changing the cursor
    shape.</p>

    <b><u>FXApp::endWaitCursor()</u></b>
    <p>A matching call to <b>endWaitCursor() </b>will
    restore the original cursor for each window.</p>

    <b><u>FXApp::setWaitCursor(cursor)</u></b>
    <p>This will change the cursor shape used in during
    a beginWaitCursor() endWaitCursor() pair.</p>

    <b><u>FXApp::getWaitCursor()</u></b><b><u></u></b>
    <p>This returns the current FXCursor being used as
    hourglass or stopwatch cursor.</p>
  </ul>

  <p>The beginWaitCursor() and endWaitCursor() calls can
  be nested pairwise, so that a functions which bracket a long calculation
  by means of a beginWaitCursor/endWaitCursor pair can call upon each other.</p>

</ul>

<!--- TOPIC TITLE -->
<p>
<table width=100% cellpadding=0 cellspacing=2><tr><td width=100% valign=bottom id=HEADLINE><b>
Drag Types
<br><img src='art/line.gif' width=100% height=1></b></td></tr></table>
</p>
<!--- TOPIC TITLE -->
<ul>
  <p>Exchanging data via the Primary Selection, the Clipboard, or by means of Drag and Drop
  requires that all applications agree with the type of data being exchanged.<br>
  This is done by registering a <b>Drag Type</b>.  In most cases, the name being
  registered should be a mime-type, such as <b>"text/plain"</b> or <b>"image/gif"</b>.</p>

  <p>Manipulating drag types is done with the following API's:</p>

  <ul>
    <b><u>FXApp::registerDragType(name)</u></b>
    <p>This will register a new drag type based on the mime type name.</p>

    <b><u>FXApp::getDragTypeName(dragtype)</u></b>
    <p>Obtain the name of a previously registered drag type.</p>
  </ul>

</ul>


<!--- COPYRIGHT -->
<p>
<table width=100% cellpadding=0 cellspacing=0><tr><td width=100% valign=top id=HEADLINE align=right>
<img src='art/line.gif' width=100% height=1><font size=-1>
Copyright &copy; 1997-2004 Jeroen van der Zijp</font>
</td></tr></table>
</p>
<!--- COPYRIGHT -->


</body>
</html>
