<html>
<head>
<LINK REL="stylesheet" HREF="styles.css" TYPE="text/css">
<title>FOX-Toolkit</title>
<!-- HTML Copyright 2001 Paul Laufer -->
</head>

<body bgcolor=#ffffff link=#990033 vlink=#4a73ad alink=#ed004f text=#000000>

<!--header-->
<table align=center border=0 cellpadding=0 cellspacing=0 width=100% >
  <tr><td bgcolor=silver colspan=5 align=right height=50><img src=art/oul_grey.gif align=left valign=top width=8 height=8><img src=art/foxlogo.png valign=bottom alt="FOX Toolkit" height=50 width=500 border=0 ></td>
  	<td bgcolor=#557faa valign=top align=right><img src=art/our.gif width=8 height=8></td>
  </tr>
<!-- end header -->
  <tr>
    <td bgcolor=#557faa colspan=2 valign=top align=left>&nbsp;</td>
    <td bgcolor=#557faa colspan=3><font color=#ffffff size=+1><center>
<!-- Page Title -->
Documentation: Regular Expressions
<!-- End Page Title -->
    </center></font></td>
    <td bgcolor=#557faa valign=top align=right>&nbsp;</td>
  </tr>
  <tr>
    <td bgcolor=#557faa colspan=2>&nbsp;</td>
    <td bgcolor=#ffffff valign=top align=left><img src=art/iul.gif width=8 height=8></td>
    <td bgcolor=#ffffff>&nbsp;</td>
    <td bgcolor=#ffffff valign=top align=right><img src=art/iur.gif width=8 height=8></td>
    <td bgcolor=#557faa width=15>&nbsp;</td>
  </tr>
  <tr>
    <td width=8 bgcolor=#557faa>&nbsp;</td>
    <td valign=top bgcolor=#557faa link=#ffffff width=150>

<!-- start navbar content -->

	<a href=fox.html><font color=#ffffff>Home</font></a><br>
	<a href=news.html><font color=#ffffff>News</font></a><br>
	<a href=download.html><font color=#ffffff>Download</font></a><br>
	<a href=goals.html><font color=#ffffff>Goals & Approach</font></a><br>
	<a href=doc.html><font color=#ffffff>Documentation</font></a><br>
	<a href=faq.html><font color=#ffffff>FAQ</font></a><br>
	<a href=rex.html><font color=#ffffff>FXRex</font></a><br>
	<a href=screenshots.html><font color=#ffffff>Screenshots</font></a><br>
	<br>
	<a href=adie.html><font color=#ffffff>Adie</font></a><br>
	<a href=pathfinder.html><font color=#ffffff>PathFinder</font></a><br>
	<a href=calc.html><font color=#ffffff>FOX Calculator</font></a><br>
	<br>
	<a href=projects.html><font color=#ffffff>Projects</font></a><br>
	<br>
	<a href='http://fxpy.sourceforge.net'><font color=#ffffff>FXPy</font></a><br>
	<a href='http://fxruby.sourceforge.net'><font color=#ffffff>FXRuby</font></a><br>
	<a href='http://eiffelfox.sourceforge.net'><font color=#ffffff>EiffelFox</font></a><br>
        <a href='http://eevolved.com/foxhole/'><font color=#ffffff>The FOX Hole</font></a><br>
        <a href='http://takahr.dhis.portside.net/cgi-bin/rwiki.cgi?cmd=view;name=FOX+FAQ'><font color=#ffffff>Japanese Docs</font></a><br>
	<br>
	<center>
	<a href="http://www.eff.org/br"><img SRC="art/freespeach.gif" border=0></a>
	<p>
	<a href="http://www.slashdot.org"><img SRC="art/slingerzbutton1.gif" border=0></a>
	</center>



<!-- end navbar content -->

    </td>
    <td bgcolor=#ffffff>&nbsp;</td>
    <td valign=top>

<!-- start main window content -->
<center><img src='art/foxstart.png'>
<BR><B>Documentation: Regular Expressions</B>
</center>
<p>
<p>
<b>What are Regular Expressions?</b>
<hr>
<P>
Regular Expressions are used to search strings for certain patterns. For example,
in a text editor you might want to search for the pattern "widgets?".  This pattern
will match occurrances of the word "widget" or "widgets" in the text.<br>
Thus, a regular expression matching facility is a necessity for writing programs
which perform text searches, syntax coloring, and so on.

<p>
<p>
<b>Anatomy of Regular Expressions</b>
<p>
A regular expression is comprised of one or more branches separated by a "|".
Each branch is made up of a sequence of pieces, and each piece is an atom optionally
followed by a repetition.
<p>
Atoms are the simplest element in a regular expression.  The simplest atoms are
individual letters.  For example, the letter "a" is an atom, and it matches a
letter "a" in the subject string.  <br>
Another kind of atom is the character class, which is simply a <em>set</em> of characters;
for example, the atom "[abcdefg]" matches one of {a,b,c,d,e,f,g} in the subject
string.  Thus, "[abcdefg]" matches "a" or "g" but not "q".  <br>
As a shorthand, you
can identify a bunch of characters by a character range, as in "[a-z]" which is
automatically translated into "[abcdefghijklmnopqrstuvwxyz]".  You can see this
is a lot shorter.
<p>
You can also simply negate the set using "^"; thus "[^a]" matches any character,
EXCEPT the "a".  To include the "]" character itself it must be used as the
first character after the "[".  To include the "-" itself it must be the first
character after the "[", the second character of the range, or the character just
before the "]".
<p>
You can embed control characters by the usual C conventions: \t for TAB, \n for
NEWLINE, and so on.  Or you can use the control-character notation, like \cH for
^H or BACKSPACE.<br>
Other characters may be entered by octal or hexadecimal
notation: \0 for octal 0, and \xff for 0xff or decimal 255 (all 256 possible
characters are legal in the subject string, FXRex does not treat any character
specially, not even the end-of-string character).
<p>
Repetitions may optionally follow an atom, making a piece.
For example, "a*" matches
"", "a", "aa", and so on.  The "*" operator matches zero or more occurrences.
There are also several other repetition operators.
The "+" operator matches one or more
occurrences, and the "?" matches zero or one occurrence.
<p>
Finally, there is also
a way to match a bounded number of occurrences.
For example, "a{3}" matches "aaa", while "a{0,3}" matches "", "a", "aa", and
"aaa", but not "aaaa".<br>
The general form of the bounded repetition is "a{n,m}" and this matches at least
n but no more than m occurrences of the preceding atom.
For convenience, we
allow omission of the n or the m; thus, "a{,m}" becomes equivalent to "a{0,m}",
and "a{n,}" becomes equivalent to "a{n,infinite}".
The special form "a{n}"
is equivalent to "a{n,n}".
<p>
Repetitions may be <em>greedy</em> or <em>lazy</em>.  Greedy repetitions are
the default; greedy repetitions will try to match as many characters as possible,
whereas lazy repetitions will try to match as few as possible.
You can indicate a lazy repetition by appending a "?".  So "a*?" is the lazy
equivalent of "a*", "a??" the lazy equivalent of "a?", and "a{2,5}?" that of
"a{2,5}".
<p>
A sequence of pieces makes up one branch.  Several branches may be separated
by a "|", and these become alternatives.  For example, the pattern "ac|dc"
matches "ac", or "dc".
<p>
Precedence rules are such that repetitions bind more strongly than sequencing,
so that "ab*" matches a single "a" followed by zero or more "b"'s.
Conversely, the "|" operator is the weakest, making the pattern "a|b*" match
either a single "a", or a sequence of zero or more "b"'s.
Explicit use of parentheses allows other precedences: "(a|b)*" is a sequence
of zero or more characters, each either "a" or "b", i.e. the same as "[ab]*".
<p>
FXRex, like PERL, offers a more convenient way to specify certain frequent
character classes; they are also faster to use when matching.
For example, "\s" matches any whitespace, "\S" matches anything other
than whitespace. The "\d" matches any digit, and is equivalent to "[0-9]". <br>
Of course,
"\D" is equivalent to "[^0-9]".  The "\l" matches any letter like "[a-zA-Z]",
and "\L" any non-letter.  "\w" matches any word character and is equivalent
to "[a-zA-Z_0-9]".  See the table below for a full list.<br>
You can use these character set shortcuts inside a character class; for example,
"[\dA-Fa-f]" is equivalent to "[0-9A-Fa-f]", which could actually also be done
more compactly by "\h" (hexdigits).
<p>
Assertions provide a way to match without consuming any characters.  You are
probably familiar with "^", which matches the begin of the line, and "$",
which matches the end of the line. FXRex also provides a few additional
assertions: "\&lt;" matches word begin, i.e. a character position such that
the previous character matches \W and the following character matches with \w.
Likewise "\&gt;" matches a word end. The "\b" and "\B" match word boundary
and word interior, respectively.
Note that the backspace character may be entered as <b>\cH</b> or <b>\x8</b>.
<p>
The ultimate in assertions is the so-called positive or negative look-ahead.
Lookahead effectively provides for arbitrarily complex positive or
negative assertions.
Unless you're familiar with PERL, you may not have seen certain features before.
First, FXRex supports additional zero-width assertions [Zero width assertions
are points in the recognition phase of a pattern where a match can pass or fail
without consuming characters from the subject string].
<p>
The "(?= ... )" and "(?! ... )" syntax is used for positive and negative look ahead,
respectively.  For example "fred(?!erick)" will match "fred" and "freddy", but
not "frederick".
<p>

<p>
Jeffrey Friedl wrote what is now the standard work on regular expressions, see
<a href="http://www.oreilly.com/catalog/regex">Mastering Regular Expressions</a>.
This book is recommended for further background on Regular Expressions.

<p>
<p>
<b>Regular Expression Grammar</b>
<hr>
FXRex accepts patterns with the following grammar:
<BR>&nbsp;
<CENTER>
<TABLE BORDER=0 CELLSPACING=0 COLS=3 WIDTH="90%">
<TR>
<TD>expression</TD><TD>::=</TD><TD>branch { "|" branch }*</TD>
</TR>
<TR>
<TD>branch</TD><TD>::=</TD><TD>{ piece }*</TD>
</TR>
<TR>
<TD>piece</TD><TD>::=</TD><TD>atom [ rep ]</TD>
</TR>
<TR>
<TD>rep</TD><TD>::=</TD><TD>( "*" | "+" | "?" | counts ) [ "?" ]</TD>
</TR>
<TR>
<TD>counts</TD><TD>::=</TD><TD>"{" digits ["," [ digits] ] "}"</TD>
</TR>
<TR>
<TD>atom</TD><TD>::=</TD><TD>"(" expression ")" | "[" [^] range "]" | characters</TD>
</TR>
<TR>
<TD>range</TD><TD>::=</TD><TD>{ character | character "-" character } +</TD>
</TR>
<TR>
<TD>characters</TD><TD>::=</TD><TD>{ character }*</TD>
</TR>
<TR>
<TD>digits</TD><TD>::=</TD><TD>{ digit }*</TD>
</TR>
</TABLE>
</CENTER>
<p>
When parsing a pattern FXRex first performs a grammar check, and measures the
resulting regex code.  Subsequently it generates the pattern code.
FXRex returns immediately when the syntax is found to be incorrect, and returns
an appropriate error code.


<p>
<p>
<b>Matching Operators</b>
<hr>
FXRex supports the following matching operators:
<BR>&nbsp;
<CENTER>
<TABLE BORDER=0 CELLSPACING=0 COLS=2 WIDTH="90%">

<TR><TD colspan=2><p><center>Basics<hr></center></TD></TR>
<TR><TD>|</TD><TD>Alternation.</TD></TR>
<TR><TD>( ... )</TD><TD>Grouping sub pattern.</TD></TR>
<TR><TD>(?i ... )</TD><TD>Match sub pattern case insensitive.</TD></TR>
<TR><TD>(?I ... )</TD><TD>Match sub pattern case sensitive.</TD></TR>
<TR><TD>(?n ... )</TD><TD>Match sub pattern with newlines.</TD></TR>
<TR><TD>(?N ... )</TD><TD>Match sub pattern with no newlines.</TD></TR>
<TR><TD>(?: ... )</TD><TD>Non-capturing parentheses.</TD></TR>
<TR><TD>[ ... ]</TD><TD>Character class.</TD></TR>
<TR><TD>[^ ... ]</TD><TD>Negated character class.</TD></TR>

<TR><TD colspan=2><p><center>Greedy Repetitions<hr></center></TD></TR>
<TR><TD>*</TD><TD>Match 0 or more.</TD></TR>
<TR><TD>+</TD><TD>Match 1 or more.</TD></TR>
<TR><TD>?</TD><TD>Match 0 or 1.</TD></TR>
<TR><TD>{}</TD><TD>Match 0 or more.</TD></TR>
<TR><TD>{n}</TD><TD>Match n times.</TD></TR>
<TR><TD>{,m}</TD><TD>Match no more than m times.</TD></TR>
<TR><TD>{n,}</TD><TD>Match n or more.</TD></TR>
<TR><TD>{n,m}</TD><TD>Match at least n but no more than m times.</TD></TR>

<TR><TD colspan=2><p><center>Lazy Repetitions<hr></center></TD></TR>
<TR><TD>*?</TD><TD>Match 0 or more.</TD></TR>
<TR><TD>+?</TD><TD>Match 1 or more.</TD></TR>
<TR><TD>??</TD><TD>Match 0 or 1.</TD></TR>
<TR><TD>{}?</TD><TD>Match 0 or more times.</TD></TR>
<TR><TD>{n}?</TD><TD>Match n times.</TD></TR>
<TR><TD>{,m}?</TD><TD>Match no more than m times.</TD></TR>
<TR><TD>{n,}?</TD><TD>Match n or more.</TD></TR>
<TR><TD>{n,m}?</TD><TD>Match at least n but no more than m times.</TD></TR>

<TR><TD colspan=2><p><center>Special Characters<hr></center></TD></TR>
<TR><TD>\a</TD><TD>Alarm, bell.</TD></TR>
<TR><TD>\e</TD><TD>Escape character.</TD></TR>
<TR><TD>\t</TD><TD>Tab.</TD></TR>
<TR><TD>\f</TD><TD>Form feed.</TD></TR>
<TR><TD>\n</TD><TD>Newline.</TD></TR>
<TR><TD>\r</TD><TD>Return.</TD></TR>
<TR><TD>\v</TD><TD>Vertical tab.</TD></TR>
<TR><TD>\cx</TD><TD>Control character.</TD></TR>
<TR><TD>\033</TD><TD>Octal.</TD></TR>
<TR><TD>\x1b</TD><TD>Hex.</TD></TR>

<TR><TD colspan=2><p><center>Character Types<hr></center></TD></TR>
<TR><TD>.</TD><TD>Match any character.</TD></TR>
<TR><TD>\w</TD><TD>Word character [a-zA-Z_0-9].</TD></TR>
<TR><TD>\W</TD><TD>Non-word character.</TD></TR>
<TR><TD>\l</TD><TD>Letter [a-zA-Z].</TD></TR>
<TR><TD>\L</TD><TD>Non-letter.</TD></TR>
<TR><TD>\s</TD><TD>Space.</TD></TR>
<TR><TD>\S</TD><TD>Non-space.</TD></TR>
<TR><TD>\d</TD><TD>Digit [0-9].</TD></TR>
<TR><TD>\D</TD><TD>Non-digit.</TD></TR>
<TR><TD>\h</TD><TD>Hex digit [0-9a-fA-F].</TD></TR>
<TR><TD>\H</TD><TD>Non-hex digit.</TD></TR>
<TR><TD>\u</TD><TD>Single uppercase character.</TD></TR>
<TR><TD>\U</TD><TD>Single lowercase character.</TD></TR>
<TR><TD>\p</TD><TD>Punctuation (not including '_').</TD></TR>
<TR><TD>\P</TD><TD>Non punctuation.</TD></TR>

<TR><TD colspan=2><p><center>Zero Width Assertions<hr></center></TD></TR>
<TR><TD>^</TD><TD>Match begin of line [if at begin of pattern].</TD></TR>
<TR><TD>$</TD><TD>Match end of line [if at end of pattern].</TD></TR>
<TR><TD>\&lt;</TD><TD>Begin of word.</TD></TR>
<TR><TD>\&gt;</TD><TD>End of word.</TD></TR>
<TR><TD>\b</TD><TD>Word boundary.</TD></TR>
<TR><TD>\B</TD><TD>Word interior.</TD></TR>
<TR><TD>\A</TD><TD>Match only beginning of string.</TD></TR>
<TR><TD>\Z</TD><TD>Match only and end of string.</TD></TR>
<TR><TD>(?= ... )</TD><TD>Positive lookahead.</TD></TR>
<TR><TD>(?! ... )</TD><TD>Negative lookahead.</TD></TR>

<TR><TD colspan=2><p><center>Other<hr></center></TD></TR>
<TR><TD>\1 ... \9</TD><TD>Back reference.</TD></TR>
<TR>
</TR>
</TABLE>
</CENTER>
<p>
<p>
<b>The FXRex Class</b>
<hr>
<P>
The FXRex class is geared toward ultimate convenience:- simple things should
be simple.  When you're interested in syntax errors, you can obtain the error
code returned by the parser.  Otherwise, the compiled pattern will simply be
set to the empty (fallback) pattern.  The fallback pattern will always
fail to match.
<p>
FXRex contains the following member functions:
<p>
<P><BR><B>FXRex</B>()
<BLOCKQUOTE>
The default constructor initializes FXRex to the fallback or empty
pattern.
</BLOCKQUOTE>
<p>
<P><BR><B>FXRex</B>(const FXRex& <B><I>orig</I></B>)
<BLOCKQUOTE>
The copy constructor initializes FXRex to the a copy of the original
pattern.
</BLOCKQUOTE>
<p>
<P><BR><B>FXRex</B>(const FXchar* <B><I>pattern</I></B>,FXint <B><I>mode</I></B>=REX_NORMAL,FXRexError* <B><I>error</I></B>=NULL)
<BLOCKQUOTE>
Parse the given pattern by calling parse.  If the parameter <B><I>error</I></B> is not NULL, the return code
of the parse will be assigned to its contents; this code will be set to REGERR_OK if the parse succeeded,
or some error code if it failed.
</BLOCKQUOTE>
<p>
<P><BR><B>FXRex</B>(const FXString& <B><I>pattern</I></B>,FXint <B><I>mode</I></B>=REX_NORMAL,FXRexError* <B><I>error</I></B>=NULL)
<BLOCKQUOTE>
Same as above, only taking an FXString as argument.
</BLOCKQUOTE>
<p>
<P><BR>FXRex&<B></B> operator=(const FXRex& <B><I>orig</I></B>)
<BLOCKQUOTE>
Assigns the compiled pattern of orig into this FXRex.
</BLOCKQUOTE>
<p>
<P><BR>FXbool<B></B> empty()
<BLOCKQUOTE>
Returns TRUE if the pattern is empty, i.e. equal to the fallback pattern which matches nothing.
</BLOCKQUOTE>
<p>
<P><BR>FXRexError<B> parse</B>(const FXchar* <B><I>pattern</I></B>,FXint <B><I>mode</I></B>=REX_NORMAL)
<BLOCKQUOTE>
Parse the given pattern, returning REGERR_OK if successful, and an error code if a syntax error has been detected.
The <B><I>mode</I></B> parameter is the bitwise OR of some flags which control various aspects of
the regular expression code being generated:
<ul>
<li><b>REX_NORMAL</b>. This is the default; the normal mode does not generate capturing
parentheses; this corresponds to the most common use of regular expression matching.<p>
<li><b>REX_CAPTURE</b>.  This flag enables the use of capturing parentheses, and back-references.<p>
<li><b>REX_ICASE</b>.  Case insensitive matching is enabled.  When backreferences are also enabled,
through the REX_CAPTURE flag, they become insensitive to case as well, so that a pattern "(aa)bb\1"
will match "aabbAA".<br>
The REX_ICASE mode can be changed using <em>cloistered</em> mode expressions
of the form "(?i ... )", which enables case-insensitive mode only for the given subexpression,
and "(?I ... )", which enables case-sensitive mode for the subexpression.<p>
<li><b>REX_NEWLINE</b>.  This will cause the <em>any character</em> type operations to also match
newlines.  It also affects the way patterns like \D (not digit) and \W (not word) and so
on work.  Without the REX_NEWLINE option, newlines do not match.<br>
The expressions "(?n ... )" and (?N ... )" can be used to change the REX_NEWLINE mode for a
subexpression.<p>
<li><b>REX_VERBATIM</b>.  This flag turns off all the magic characters (including backslash
escape sequences).  The corresponding regular expression program therefore degenerates into
a simple literal match.  If REX_ICASE has also been passed, a literal case-insensitive
match results.<br>
The REX_VERBATIM flag is useful to allow building regular expression programs even when no
special matching is required.<p>
<li><b>REX_SYNTAX</b>. When this flag is passed, the pattern is parsed normally, but no
code is generated.  This option is useful to test the regular expression pattern for
syntactical correctness only.
</ul>
When parsing fails, or when REX_SYNTAX is passed, the regular expression object will be
initialized to the fallback program; in other words, the regular expression will
be <em>empty</em>.  All matches attempted with the empty pattern will fail.
</BLOCKQUOTE>
<p>
<P><BR>FXRexError<B> parse</B>(const FXString& <B><I>pattern</I></B>,FXint <B><I>mode</I></B>=REX_NORMAL)
<BLOCKQUOTE>
Same as above, only taking an FXString as argument.
</BLOCKQUOTE>
<p>
<P><BR>FXbool<B> match</B>(const FXchar* <B><I>string</I></B>,FXint <B><I>len</I></B>,FXint* <B><I>beg</I></B>=NULL,FXint* <B><I>end</I></B>=NULL,FXint <B><I>mode</I></B>=REX_FORWARD,FXint <B><I>npar</I></B>=1,FXint <B><I>fm</I></B>=0,FXint <B><I>to</I></B>=2147483647)
<BLOCKQUOTE>
Match the given subject <B><I>string</I></B> of length <B><I>len</I></B>, and returns TRUE if the pattern matches.
if <B><I>beg</I></B> and <B><I>end</I></B> are not NULL, (beg[0],end[0]) will contain the offsets relative
to the begin of <B><I>string</I></B> where the match started/ended, and (beg[i],end[i]) will contain the
offsets where sub-expression i started/ended, or (-1,-1) if the corresponding subexpression was not
matched.
The search is performed in the range [<B><I>fm</I></B>,<B><I>to</I></B>].
<p>
The <B><I>mode</I></B> parameter is a bitwise OR of some flags which control how the string is to
be matched by the pattern:
<ul>
<li><b>REX_FORWARD</b>.  This is the default.  REX_FORWARD causes the matcher to scan the subject
string starting from offset <B><I>fm</I></B> up to and including offset <B><I>to</I></B>.<p>
<li><b>REX_BACKWARD</b>. Scan the subject string, moving backwards starting from <B><I>to</I></B>
down to offset <B><I>fm</I></B>.
An important special case is when <B><I>fm</I></B> and <B><I>to</I></B> are the same; in this case,
only a single attempt is made at the indicated offset.
Observe also that while the scan is performed between <B><I>fm</I></B> and <B><I>to</I></B>, the
actual subject string matched may extend past this range!<p>
<li><b>REX_NOT_BOL</b>. Normally, it is assumed that the start of the subject string is also the start of a
line; however passing the flag REX_NOT_BOL suppresses this behavior.  When passed, only positions immediately
following a newline will match the "^" assertion.<p>
<li><b>REX_NOT_EOL</b>. This suppresses the interpretation of the end of the subject string as the end
of a line; when passed, only positions preceding a newline will match the "$" assertion.<br>
The flags REX_NOT_BOL and REX_NOT_EOL are useful when you need to match against a random chunk of
text.<P>
<li><b>REX_NOT_EMPTY</b>. Disallow empty strings from matching.  When passed,
an empty string is <b>NOT</b> considered a match; for example, if the pattern:
<p>
<BLOCKQUOTE>
a?b?
</BLOCKQUOTE>
<p>
is applied to a string not beginning with  "a"  or  "b",  it
matches  the  empty string at the start of the subject.
With the REX_NOT_EMPTY flag, this match is not valid, so FXRex searches
further into the string for occurrences of "a" or "b".

For example, when searching for pattern "a*"
in "bbba", normally "" would be matched, as zero repetitions of "a" is normally possible.  With REX_NOT_EMPTY,
the single "a" will be matched instead. <br>
This is usually what people expect to happen.
</ul>

<p>
The parameter <B><I>npar</I></B> controls the length of the beg/end arrays.  It should
be set to at least 1.
If the pattern has been compiled with REX_CAPTURE, any capturing sub-expressions at a level
greater than <B><I>npar</I></B> will operate as if they were non-capturing subexpressions.
Thus, backreferences greater than <B><I>npar</I></B> will fail.<br>
Hence it is important to pass a value for <B><I>npar</I></B> which is at least as large
as the expected number of capturing subexpressions.
<p>
The parameters <B><I>fm</I></B> and <B><I>to</I></B> furnish the matcher with the range of the
text to be searched.  Making <B><I>fm</I></B> and <B><I>to</I></B> equal will force the
matcher to perform a single matching attemt at the given offset.
</BLOCKQUOTE>
<p>
<P><BR>FXbool<B> match</B>(const FXString& <B><I>string</I></B>,FXint* <B><I>beg</I></B>=NULL,FXint* <B><I>end</I></B>=NULL,FXint <B><I>mode</I></B>=REX_FORWARD,FXint <B><I>npar</I></B>=1,FXint <B><I>fm</I></B>=0,FXint <B><I>to</I></B>=2147483647)
<BLOCKQUOTE>
Same as above, only taking an FXString parameter.
</BLOCKQUOTE>

<p>
<P><BR>static const FXchar*<B> getError</B>(FXRexError <B><I>error</I></B>)
<BLOCKQUOTE>
Returns a pointer to a string containing a human-readable error message for the given
<B><I>error</I></B> code.
</BLOCKQUOTE>
<p>
<P><BR>FXbool<B> operator==</B>(const FXRex& <B><I>r1</I></B>,const FXRex& <B><I>r2</I></B>)
<P>FXbool<B> operator!=</B>(const FXRex& <B><I>r1</I></B>,const FXRex& <B><I>r2</I></B>)
<BLOCKQUOTE>
Compares regular expression <B><I>r1</I></B> and <B><I>r2</I></B>.
<B><I>error</I></B> code.
</BLOCKQUOTE>
<p>
<P><BR>FXStream&<B> operator<<</B>(FXStream& <B><I>store</I></B>,const FXRex& <B><I>s</I></B>)
<P>FXStream&<B> operator>></B>(FXStream& <B><I>store</I></B>,FXRex& <B><I>s</I></B>)
<BLOCKQUOTE>
Serialize and deserialize regular expression <B><I>s</I></B> to/from stream <B><I>store</I></B>.
</BLOCKQUOTE>
<p>


<p>
<p>
<b>Using the FXRex class</b>
<hr>
<P>
FXRex is most easy to use.  The simplest usage is something like:
<p>
<center><table BORDER CELLSPACING=0 COLS=1 WIDTH="90%" BGCOLOR="#FFF8E1" NOSAVE >
<tr>
<td>
<br><tt>// A letter or underscore followed by a letters, digits, or underscores</tt>
<br><tt>FXRex identifier("[a-zA-Z_][a-zA-Z0-9_]*");</tt>
<br><tt>FXString string;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>if(identifier.match(string)){  /* found it ... */ }</tt>
</td>
</tr>
</table></center>
<p>
The usage above is the simplest possible:- we just want to know if the pattern is
contained in the string.
If we need to execute a pattern only once, more crufty C++ implementor would
probably write:
<p>
<center><table BORDER CELLSPACING=0 COLS=1 WIDTH="90%" BGCOLOR="#FFF8E1" NOSAVE >
<tr>
<td>
<br><tt>if(FXRex("[a-zA-Z_][a-zA-Z0-9_]*").match(string)){  /* found it ... */ }</tt>
</td>
</tr>
</table></center>
<p>
Its so nice to be able to do that in 1 line of code, isn't it?<br>
Most of the time, we want to know more; not only whether there was a match or not,
but also where in the string the pattern was found:
<p>
<center><table BORDER CELLSPACING=0 COLS=1 WIDTH="90%" BGCOLOR="#FFF8E1" NOSAVE >
<tr>
<td>
<br><tt>// A letter or underscore followed by a letters, digits, or underscores</tt>
<br><tt>FXRex identifier("[a-zA-Z_][a-zA-Z0-9_]*");</tt>
<br><tt>FXString string;</tt>
<br><tt>FXint beg,end;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>if(identifier.match(string,&amp;beg,&amp;end)){ </tt>
<br><tt>&nbsp;&nbsp;// Return the matching part</tt>
<br><tt>&nbsp;&nbsp;return string.mid(beg,end-beg);</tt>
<br><tt>&nbsp;&nbsp;}</tt>
</td>
</tr>
</table></center>
<p>
If we have enabled capturing parentheses, we can extract even more information;
not only where the whole pattern matched, but also where each subpattern was found.
The following code fragment which breaks up a floating point number into a
sign,mantissa, and exponent using the pattern "(-|\+|)(\d*\.\d*)(E(-|\+|)\d+)?"
illustrates the technique:
<p>
<center><table BORDER CELLSPACING=0 COLS=1 WIDTH="90%" BGCOLOR="#FFF8E1" NOSAVE >
<tr>
<td>
<br><tt>// Pick apart a floating point number</tt>
<br><tt>FXRex number("(-|\+|)(\d*\.\d*)(E(-|\+|)\d+)?",REX_CAPTURE);</tt>
<br><tt>FXString string,sign,mantissa,exponent;</tt>
<br><tt>FXint beg[5],end[5];</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>if(number.match(string,beg,end,REX_FORWARD,5)){ </tt>
<br><tt>&nbsp;&nbsp;// Get the sign</tt>
<br><tt>&nbsp;&nbsp;sign=string.mid(beg[1],end[1]-beg[1]);</tt>
<br><tt>&nbsp;&nbsp;// Get the mantissa</tt>
<br><tt>&nbsp;&nbsp;mantissa=string.mid(beg[2],end[2]-beg[2]);</tt>
<br><tt>&nbsp;&nbsp;// Get the exponent</tt>
<br><tt>&nbsp;&nbsp;exponent=string.mid(beg[3],end[3]-beg[3]);</tt>
<br><tt>&nbsp;&nbsp;}</tt>
</td>
</tr>
</table></center>
<p>
Note that we're passing npar=5 as the last argument because there are 5 pairs
of values returned in the beg[] and end[] arrays: (beg[0],end[0]) contains the
entire pattern, (beg[1],end[1]) the sign, (beg[2],end[2]) the mantissa, (beg[3],end[3])
the exponent, and (beg[4],end[4]) the sign of the exponent.<br>
If a particular sub-expression is not matched (for example, if there is no exponent),
then the corresponding entry will contain (-1,-1).<br>
Because it needs to record where a sub-expression matches, its quite expensive
to use capturing parentheses when we don't need to.  Fortunately, there's a
solution for this:
<p>
<center><table BORDER CELLSPACING=0 COLS=1 WIDTH="90%" BGCOLOR="#FFF8E1" NOSAVE >
<tr>
<td>
<br><tt>// Pick apart a floating point number</tt>
<br><tt>FXRex number("(-|\+|)(\d*\.\d*)(E(?:-|\+|)\d+)?",REX_CAPTURE);</tt>
<br><tt>FXString string,sign,mantissa,exponent;</tt>
<br><tt>FXint beg[4],end[4];</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>if(number.match(string,beg,end,REX_FORWARD,4)){ </tt>
<br><tt>&nbsp;&nbsp;// Get the sign</tt>
<br><tt>&nbsp;&nbsp;sign=string.mid(beg[1],end[1]-beg[1]);</tt>
<br><tt>&nbsp;&nbsp;// Get the mantissa</tt>
<br><tt>&nbsp;&nbsp;mantissa=string.mid(beg[2],end[2]-beg[2]);</tt>
<br><tt>&nbsp;&nbsp;// Get the exponent</tt>
<br><tt>&nbsp;&nbsp;exponent=string.mid(beg[3],end[3]-beg[3]);</tt>
<br><tt>&nbsp;&nbsp;}</tt>
</td>
</tr>
</table></center>
<p>
The syntax "(?: ... )" makes the enclosed expression a non-capturing one.  Note
that this also means we can make do with one less entry in the beg and end arrays,
as we're getting one fewer return value.
<p>
If the npar parameter is too small, then any capturing parentheses level greater
than npar will behave as a non-capturing parenthesis (however, if back references
are also used, a back reference to a capturing parenthesis greater than npar
will cause the match to fail!).
<p>
The example below determines if there is a floating point number at
offset pos in the string:
<p>
<center><table BORDER CELLSPACING=0 COLS=1 WIDTH="90%" BGCOLOR="#FFF8E1" NOSAVE >
<tr>
<td>
<br><tt>// Does string starting at pos match a floating point number?</tt>
<br><tt>FXRex number("(-|\+|)(\d*\.\d*)(E(-|\+|)\d+)?",REX_NORMAL);</tt>
<br><tt>FXString string;</tt>
<br><tt>FXint pos;</tt>
<br><tt>&nbsp; ...</tt>
<br><tt>if(number.match(string,NULL,NULL,REX_FORWARD,1,pos,pos)){ </tt>
<br><tt>&nbsp;&nbsp;...</tt>
<br><tt>&nbsp;&nbsp;// YES</tt>
<br><tt>&nbsp;&nbsp;...</tt>
<br><tt>&nbsp;&nbsp;}</tt>
</td>
</tr>
</table></center>
<p>
Since both starting and ending offsets are the same, the matcher makes only
a single attempt at matching the pattern at the offset pos; it does not scan
the whole subject string.

<P>
<!-- end main window content -->

    </td>
    <td bgcolor=#ffffff>&nbsp;</td>
    <td bgcolor=#557faa width=15>&nbsp;</td>
  </tr>
  <tr>
    <td colspan=2 bgcolor="#557faa" align=center>&nbsp;
     </td>
    <td bgcolor=#ffffff valign=bottom align=left><img src=art/ill.gif width=8 height=8></td>
    <td bgcolor=#ffffff>&nbsp;</td>
    <td bgcolor=#ffffff valign=bottom align=right><img src=art/ilr.gif width=8 height=8></td>
    <td bgcolor=#557faa width=15>&nbsp;</td>
  </tr>
  <tr>
    <td valign=bottom align=left bgcolor=#557faa><img src=art/oll.gif width=8 height=8></td>
    <td colspan=4 bgcolor=#557faa>&nbsp;</td>
    <td valign=bottom align=right bgcolor=#557faa><img src=art/olr.gif width=8 height=8></td>
  </tr>
</table>

<address>Copyright 1997-2002 <a href=mailto:jeroen@fox-toolkit.org>Jeroen van der Zijp</a></address>
<!-- Created: Mon Apr 10 11:20:32 CEST 2000 -->
<!-- hhmts start -->

<!-- hhmts end -->
</body>
</html>
