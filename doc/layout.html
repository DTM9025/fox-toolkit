<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05 [en] (X11; I; Linux 2.0.34 i686) [Netscape]">
   <META NAME="Author" CONTENT="Jeroen van der Zijp">
   <TITLE>Layout Managers</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFEDED" LINK="#0000EF" VLINK="#51188E" ALINK="#FF0000" BACKGROUND="foxback.gif">

<CENTER><U><FONT COLOR="#990000"><FONT SIZE=+4>Widget Layout</FONT></FONT></U></CENTER>

<CENTER>&nbsp;</CENTER>
<A NAME="LAYOUT"></A><U><FONT COLOR="#990000"><FONT SIZE=+4>Placing Widgets.</FONT></FONT></U>

<P><FONT COLOR="#000000">Making an attractive layout for a Dialog or Window&nbsp;
is an important consideration in design of a user interface.&nbsp; Setting
windows at specific x,y coordinates, and specifying explicit dimensions
allow the GUI designer full control over&nbsp; the placement of each Control.&nbsp;
However, this is very tedious and time-consuming.&nbsp; Also, what if the
labels on buttons change, or if the user wants to use a bigger font?</FONT>

<P><FONT COLOR="#000000">For these reasons, the preferred method for placing
GUI Controls on windows in FOX is through the use of so-called Layout Managers.&nbsp;
A Layout manager is a widget whose primary purpose is to arrange GUI Controls
contained in it in a certain way in its interior.&nbsp; The benefits of
this approach vis-a-vis a precise and explicit placement is that:</FONT>
<OL>
<LI>
<FONT COLOR="#000000">It takes the tedium out of placing GUI Controls;
the application programmer does not concern him or herself with specific
coordinates.</FONT></LI>

<LI>
<FONT COLOR="#000000">GUI Controls are automatically arranged correctly,
even if button labels are changed, or users choose bigger fonts.</FONT></LI>

<LI>
<FONT COLOR="#000000">Layouts may be recalculated intelligently when a
user resizes the window.</FONT></LI>

<LI>
<FONT COLOR="#000000">It makes it easy to accomodate and place Controls
which are created automatically under program control.</FONT></LI>
</OL>
<FONT COLOR="#000000">In FOX, you determine the arrangement of&nbsp; a
GUI Control&nbsp; by selecting the appropriate Layout Managers, and a combination
of <I>Packing Styles </I>passed to the Layout Manager, as well as a combination
of <I>Layout Hints</I> passed to the GUI Control being arranged.&nbsp;
Thus, virtually every conceivable arrangement can be achieved.</FONT>

<P><FONT COLOR="#000000">Note that FOX allows nesting of Layout Managers;
a nested Layout Manager can thus have both a Packing Style as well as Layout
Hints!</FONT>

<P><FONT COLOR="#000000">FOX supports a number of general-purpose layout
managers.&nbsp; The desired arrangement of GUI controls determines which
layout manager is the most appropriate for the job; the following table
lists the most commonly used layout managers and their layout arrangement:</FONT>
<BR>&nbsp;
<BR>&nbsp;
<TABLE BORDER CELLPADDING=5 WIDTH="100%" NOSAVE >
<TR NOSAVE>
<TD VALIGN=TOP NOSAVE><B><FONT SIZE=+2>FXPacker</FONT></B></TD>

<TD>The Packer layout widget&nbsp; places its GUI elements in its interior
rectangle, placing each child against one of the four sides.&nbsp; As each
child is placed, the size of the rectangle is reduced by the space taken
up by the child.&nbsp;
<BR>If a child is placed against the left or right, the interior rectangle's
width is reduced; if the child is placed against the top or bottom, the
height is reduced.&nbsp;
<BR>Children may be of any type, including other layout managers.</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP NOSAVE><B><FONT SIZE=+2>FXTopWindow</FONT></B></TD>

<TD NOSAVE>The TopWindow operates like an FXPacker window.&nbsp; For simple
dialogs and toplevel windows, no additional layout managers may be needed
in many cases, as the TopWindow's layout characteristics may be sufficient.</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP NOSAVE><B><FONT SIZE=+2>FXHorizontalFrame</FONT></B></TD>

<TD>The HorizontalFrame layout manager packs its children horizontally
from left to right (or right to left).&nbsp;</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP NOSAVE><B><FONT SIZE=+2>FXVerticalFrame</FONT></B></TD>

<TD>The VerticalFrame layout manager packs its children vertically, from
top to bottom or vice versa.&nbsp; It behaves similar to the HorizontalFrame
layout manager.</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP NOSAVE><B><FONT SIZE=+2>FXMatrix</FONT></B></TD>

<TD>The Matrix layout manager arranges its children in rows and columns.
An FXMatrix widget can operate in both column-oriented as well as row-oriented
mode.&nbsp; Normally, the Matrix layout manager operates row-wise.&nbsp;
Based on the number of rows, the Matrix layout determines the width of
each column and the height of each row, then arranges the children in the
space allotted, observing the child's layout hints as much as possible.&nbsp;</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP NOSAVE><B><FONT SIZE=+2>FXSwitcher</FONT></B></TD>

<TD NOSAVE>The Switcher layout manager places its children exactly on top
of each other; it ignores most of the layout hints provided by each child.&nbsp;
You typically use a layout manager like the switcher to save screen real-estate,
by placing for example several control panels on top of each other, and
bringing the right one on top depending on the context.</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP NOSAVE><B><FONT SIZE=+2>FXGroupBox</FONT></B></TD>

<TD>The GroupBox is a layout manager that provides identical layout facilities
as the Packer.&nbsp; In addition, the GroupBox draws an attractive border
around its contents, and provides an optional caption.&nbsp; Finally,&nbsp;
if its children are RadioButtons, it forces at most one of these to be
checked.</TD>
</TR>

<TR NOSAVE>
<TD VALIGN=TOP NOSAVE><B><FONT SIZE=+2>FXSplitter</FONT></B></TD>

<TD>The Splitter layout manager divides some area of the screen horizontally
or vertically.&nbsp; The divider bars can be repositioned by the user,
so that depending on what the user is doing, he or she may give one or
the other partition more screen space.</TD>
</TR>
</TABLE>
&nbsp;

<P>&nbsp;
<BR><U><FONT COLOR="#990000"><FONT SIZE=+4>How Layout Works.</FONT></FONT></U>

<P><FONT COLOR="#000000">All widgets in FOX are organized into a <I>widget</I>
<I>hierarchy</I> or <I>widget-tree</I>.&nbsp; Widgets are roughly classified
as <I>Composite</I> widgets, and <I>Simple</I> widgets.&nbsp; Composite
widgets can have child widgets, whereas Simple widgets are the most basic
type of widget.</FONT>&nbsp;&nbsp; <FONT COLOR="#000000">One widget is
at the top of the widget hierarchy: the <I>RootWindow</I> widget.&nbsp;
This special widget represents the background screen on your display.</FONT>&nbsp;&nbsp;
<FONT COLOR="#000000">Widgets below the RootWindow widgets are called <I>Shell</I>
widgets.&nbsp; Shell widgets are positioned and resized directly by the
end-user, typically through resize handles and title-bars provided by a
<I>Window Manager</I>.</FONT>

<P><FONT COLOR="#000000">As a user resizes a Shell widget, layout needs
to be performed to reposition each widget in that Shell so as to maintain
the proper arrangement.&nbsp; Hence, we refer to the <I>layout</I> process
as going <B><I>top-down</I></B>, i.e. proceeding from widgets higher up
in the widget tree downward toward the leaves of the tree.</FONT>

<P><FONT COLOR="#000000">Sometimes, however, widgets may want to change
size of their own accord.&nbsp; For example, an application changes the
text on a Label widget, making it larger. Changing a widget's size demands
that its immediate parent be notified, as widgets are arranged by their
parents.&nbsp; Depending on the arrangement, the widget's parent may decide
that it, too, may need to change size, and in its turn notify its parent.&nbsp;
Thus process goes on all the way till some widget is encountered whose
size is not affected by the change.&nbsp; Thus, we refer to the <I>recalculation</I>
process as going <B><I>bottom-up.</I></B></FONT>

<P><FONT COLOR="#000000">In the course of recursing upwards, all widgets
are marked for later layout.&nbsp; The upward traversal will typcally be
stopped because of one of the following reasons:</FONT>
<OL>
<LI>
<FONT COLOR="#000000"><B>The widget is a Shell widget</B>.&nbsp; Shell
widgets are resized by the user only, so the size will not change, and
layout will have to be performed as well as possible given the size of
the Shell widget.</FONT></LI>

<LI>
<FONT COLOR="#000000"><B>The widget is a ScrollWindow widget.</B>&nbsp;
A ScrollWindow does not have to grow or shrink when its child does:- it
just adjusts the scrollbars to reflect the new child size, and layout the
child properly.</FONT></LI>

<LI>
<FONT COLOR="#000000"><B>The widget is able to accomodate the child's new
size.&nbsp; </B>For example, it may be that the child that changed was
not the determining factor that caused the parent's size; in such a case,
no further marking needs to take place.</FONT></LI>
</OL>
<FONT COLOR="#000000"><FONT SIZE=+0>During idle processing,&nbsp; all marked
widgets will be laid out by the system, and their mark-flags will be reset.&nbsp;
Thus, during processing of a user-event, any number of things may be changed
in the User Interface; still, only one pass will be performed to rearrange
all widgets again.&nbsp; This is one of the reasons for FOX's fast performance
for large-scale graphical user interfaces.</FONT></FONT>
<BR>&nbsp;

<P><U><FONT COLOR="#990000"><FONT SIZE=+4>About Default Sizes.</FONT></FONT></U>

<P><FONT COLOR="#000000">All widgets may be requested to compute their
<I>default size</I>. Layout widgets will use this information to determine
their own default size.&nbsp; Mostly, layout managers will try and ensure
that a child-widget will not be made smaller than its reported default
size.&nbsp; Note that the default size is normally the minimum size that
is sensible for a widget, but that a widget may potentially become smaller
than its default size!</FONT>
<BR><FONT COLOR="#000000">For most types of Controls, the default size
is computed based on the content, such as a text label and icon, plus borders
and perhaps some interior padding; most Controls have a border, which may
be 0, 1, or 2 pixels wide, and an interior padding around the top, bottom,
left, and right side.&nbsp; The interior padding provides some spacing
around the content for visual aesthetics.&nbsp; For Layout Managers, the
default size is computed based on the arrangement of the children, their
default sizes, its own border, interior padding, and inter-child spacing.</FONT>

<P>&nbsp;
<BR><U><FONT COLOR="#990000"><FONT SIZE=+4>Layout Hints.</FONT></FONT></U>

<P><FONT COLOR="#000000">With layout hints, widgets can inform their parent
layout widget of certain desired positioning and sizing requirements. Since
they are just hints, these may not always be observed.&nbsp; Generally,
however, the layout widgets will try and do their best to observe the hints
insofar as possible.</FONT>

<P><FONT COLOR="#000000">The absence of a specific hint usually indicates
that a default value is to be chosen.&nbsp; So in many cases, you do not
need to fully specify all hints at all!&nbsp; In complicated situations,
however, you may have to specify many of these hints.&nbsp; The&nbsp; FOX
toolkit has defined the hints in such a way that the most common situations
require the fewest hint-flags; for example, normally, Layout Managers are
filled from top to bottom, and left to right.&nbsp; Thus, you wouldn't
have to specify these hints if this is the case!</FONT>

<P><FONT COLOR="#000000">We will subsequently describe the layout hints
and their effect on the typical layout process; we have indicated the default
option between parentheses; it is usually the case that the default options
do not have to be specified explicitly.</FONT>
<BR>&nbsp;

<P>&nbsp;
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR>
<TD><U><FONT SIZE=+3>Layout Hint:</FONT></U></TD>

<TD><U><FONT SIZE=+3>Where</FONT></U>:</TD>

<TD><U><FONT SIZE=+3>Effect:</FONT></U></TD>
</TR>

<TR NOSAVE>
<TD><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_SIDE_TOP&nbsp; (default)</FONT></FONT></B>&nbsp;
<BR><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_SIDE_BOTTOM</FONT></FONT></B>&nbsp;
<BR><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_SIDE_LEFT</FONT></FONT></B>&nbsp;
<BR><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_SIDE_RIGHT</FONT></FONT></B>&nbsp;</TD>

<TD NOSAVE>FXPacker,&nbsp;
<BR>FXGroupBox,&nbsp;
<BR>FXTopLevel,&nbsp;
<BR><I><FONT COLOR="#FF6666">only</FONT></I></TD>

<TD NOSAVE><FONT COLOR="#000000">If you specify <B><I>one</I></B> of these
four options, the child widget will be stuck to the top, bottom, left,
or right, respectively in the layout manager cavity.&nbsp; The cavity's
size will be reduced by the amount lopped off by the packed widget.&nbsp;
LAYOUT_SIDE_TOP/LAYOUT_SIDE_BOTTOM will reduce the height of the cavity,
and LAYOUT_SIDE_LEFT/LAYOUT_SIDE_RIGHT will reduce the width.</FONT>&nbsp;
<BR>For other composite widgets, these options may not have any effect</TD>
</TR>

<TR>
<TD><B><FONT SIZE=-1>LAYOUT_FILL_ROW</FONT></B>
<BR><B><FONT SIZE=-1>LAYOUT_FILL_COLUMN</FONT></B></TD>

<TD>FXMatrix
<BR><I><FONT COLOR="#FF6666">only</FONT></I></TD>

<TD>If LAYOUT_FILL_COLUMN is specified for all child widgets in a Matrix
layout manager, the whole column can stretch if the Matrix itself is stretched
horizontally.&nbsp; Analoguously, if LAYOUT_FILL_ROW is specified for all
child widgets in a row, the whole row is stretched if the Matrix layout
manager is stretched vertically.</TD>
</TR>

<TR NOSAVE>
<TD><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_LEFT (default)</FONT></FONT></B>&nbsp;
<BR><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_RIGHT</FONT></FONT></B>&nbsp;</TD>

<TD NOSAVE><I><FONT COLOR="#FF6666">all</FONT></I></TD>

<TD NOSAVE>The widget will be placed on the left-side, or right side of
the space remaining in the container.&nbsp; When used for a child of FXPacker
cum suis, the hint will be ignored unless either LAYOUT_SIDE_TOP or LAYOUT_SIDE_BOTTOM
is specified.</TD>
</TR>

<TR NOSAVE>
<TD><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_TOP (default)</FONT></FONT></B>&nbsp;
<BR><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_BOTTOM</FONT></FONT></B>&nbsp;</TD>

<TD NOSAVE><I><FONT COLOR="#FF6666">all</FONT></I></TD>

<TD NOSAVE>The widget will be placed on the top-side or bottom-side of
the space remaining in the container.&nbsp; For a child of FXPacker c.s.,
these options will only have effect if either LAYOUT_SIDE_RIGHT or LAYOUT_SIDE_LEFT
is specified.</TD>
</TR>

<TR NOSAVE>
<TD><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_FIX_X</FONT></FONT></B>&nbsp;
<BR><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_FIX_Y</FONT></FONT></B></TD>

<TD NOSAVE><I><FONT COLOR="#FF6666">all</FONT></I></TD>

<TD NOSAVE><FONT COLOR="#000000">Either none, one, or both of these hints
may be specified.&nbsp; The LAYOUT_FIX_X hint will cause the parent layout&nbsp;
widget to place this widget at the indicated X position, as passed on the
optional arguments in the widgets constructor argument list. Likewise,
a LAYOUT_FIX_Y hint will cause placement at the indicated Y position.</FONT>&nbsp;&nbsp;
<FONT COLOR="#000000">Note that the X and Y position is specified in the
<I>parent's coordinate system</I>.</FONT></TD>
</TR>

<TR>
<TD><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_FIX_WIDTH</FONT></FONT></B>&nbsp;
<BR><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_FIX_HEIGHT</FONT></FONT></B>&nbsp;</TD>

<TD><I><FONT COLOR="#FF6666">all</FONT></I></TD>

<TD>These options will fix the widgets width (resp. height) to the value
specified on the constructor.&nbsp; You can change the widget's size using
setWidth() and setHeight(), under program control; however, the layout
manager will generally observe the specified dimensions of the widget without
trying to modify it (unless other options override).</TD>
</TR>

<TR>
<TD><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_MIN_WIDTH (default)</FONT></FONT></B>&nbsp;
<BR><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_MIN_HEIGHT (default)</FONT></FONT></B>&nbsp;</TD>

<TD><I><FONT COLOR="#FF6666">all</FONT></I></TD>

<TD><FONT COLOR="#000000">Either none, one, or both of these hints may
be specified. You will almost never specify these options, except perhaps
for code legibility.&nbsp; If LAYOUT_FIX_WIDTH or LAYOUT_FIX_HEIGHT are
not specified, these options will cause the parent layout widget to use
the default (or minimum) width and height, respectively.</FONT>&nbsp;</TD>
</TR>

<TR>
<TD><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_CENTER_X</FONT></FONT></B>&nbsp;
<BR><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_CENTER_Y</FONT></FONT></B>&nbsp;</TD>

<TD><I><FONT COLOR="#FF6666">all</FONT></I></TD>

<TD>The widget will be centered in the x-direction (y-direction) in the
parent.&nbsp; Extra spacing will be added around the widget to place it
at the center of the space available to it.&nbsp; The widget's size will
be its default size unless LAYOUT_FIX_WIDTH or LAYOUT_FIX_HEIGHT have been
specified.</TD>
</TR>

<TR>
<TD><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_FILL_X</FONT></FONT></B>&nbsp;
<BR><B><FONT COLOR="#000000"><FONT SIZE=-1>LAYOUT_FILL_Y</FONT></FONT></B>&nbsp;</TD>

<TD><I><FONT COLOR="#FF6666">all</FONT></I></TD>

<TD><FONT COLOR="#000000">Either none, one, or both of these hints may
be specified.&nbsp; LAYOUT_FILL_X will cause the parent layout manager
to stretch or shrink the widget to accomodate the available space.&nbsp;
If more than one child with this option is placed side by side, the available
space will be subdivided proportionally to their default size.</FONT>&nbsp;
<BR><FONT COLOR="#000000">LAYOUT_FILL_Y has the identical effect on the
vertical direction.</FONT>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;

<P>&nbsp;
<BR><U><FONT COLOR="#990000"><FONT SIZE=+4>General Purpose Layout Managers.</FONT></FONT></U>

<P><FONT COLOR="#000000">All general-purpose layout widgets have interior
padding, to offset their child-widgets by some amount from the left, right,
top, and bottom edge of the layout manager's interior edges, as well as
horizontal and vertical spacing, which is extra space placed between child-widgets
to prevent them from being stuck too close together.</FONT>
<BR><FONT COLOR="#000000">As usual, sensible default values are automatically
supplied in the optional arguments on the constructor argument list so
that in many cases, you will not need to specify specific values yourself.</FONT>

<P>All layout managers support the so-called packing styles:
<BR>&nbsp;

<P><U><FONT COLOR="#990000"><FONT SIZE=+4>Packing Styles.</FONT></FONT></U>

<P>The Layout managers support a number of packing styles which can influence
the way their children are arranged.&nbsp; These packing style flags override
hints that child widgets may supply.&nbsp; The following packing styles
are available:
<BR>&nbsp;
<BR>&nbsp;
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR NOSAVE>
<TD NOSAVE><U><FONT SIZE=+3>Packing Style:</FONT></U></TD>

<TD><U><FONT SIZE=+3>Effect:</FONT></U></TD>
</TR>

<TR>
<TD><B><FONT COLOR="#000000"><FONT SIZE=-1>PACK_UNIFORM_HEIGHT</FONT></FONT></B>&nbsp;</TD>

<TD>The PACK_UNIFORM_HEIGHT packing style causes the Layout Manager to
compute the height of the tallest of its children, and then subsequently
use this as the height for the remaining layout computations.&nbsp; You
can use this option to easily force different widgets to be the same height.</TD>
</TR>

<TR>
<TD><B><FONT COLOR="#000000"><FONT SIZE=-1>PACK_UNIFORM_WIDTH</FONT></FONT></B>&nbsp;</TD>

<TD>Like PACK_UNIFORM_HEIGHT, PACK_UNIFORM_WIDTH forces each widget to
be the same width.&nbsp; The widget's own preferences such as LAYOUT_FIX_WIDTH
are overridden.</TD>
</TR>
</TABLE>
&nbsp;
<BR>&nbsp;

<P><U><FONT COLOR="#990000"><FONT SIZE=+4>Matrix Layout Widget.</FONT></FONT></U>

<P><FONT COLOR="#000000">The Matrix layout widget positions its children
in nice rows and columns.&nbsp; Besides the common General Purpose Layout
options, Matrix also supports the following layout styles:</FONT>
<BR>&nbsp;
<TABLE BORDER WIDTH="100%" NOSAVE >
<TR>
<TD><U><FONT SIZE=+3>Matrix Style:</FONT></U></TD>

<TD><U><FONT SIZE=+3>Effect:</FONT></U></TD>
</TR>

<TR>
<TD><B><FONT SIZE=-1><FONT COLOR="#000000">MATRIX_BY_ROWS&nbsp;</FONT>
(default)</FONT></B>&nbsp;</TD>

<TD>The MATRIX_BY_ROWS is the default, and usually does not need to be
specified.&nbsp;</TD>
</TR>

<TR>
<TD><B><FONT COLOR="#000000"><FONT SIZE=-1>MATRIX_BY_COLUMNS</FONT></FONT></B>&nbsp;</TD>

<TD>When MATRIX_BY_COLUMNS is specified, the number of columns of the matrix
is fixed, and equal to the number specified on the constructor argument
list;&nbsp; the number of rows is determined by the total number of children.&nbsp;
<BR>Conversely, if MATRIX_BY_COLUMNS is not specified, the number of rows
is fixed and the number of columns is determined by the number of children.&nbsp;</TD>
</TR>
</TABLE>
&nbsp;

<P>In either case, Matrix places children top to bottom, left to right
(left to right, top to bottom for MATRIX_BY_COLUMNS),&nbsp; and determines
the height of each row and width of each column as follows:
<BR>&nbsp;
<OL>
<LI>
If a column&nbsp; contains children which all have set the property LAYOUT_FILL_COLUMN,
the whole column will be considered stretchable.&nbsp; The amount of stretch
is proportionally disbursed between the stretchable columns.</LI>

<LI>
If a row contains children which all have set the property LAYOUT_FILL_ROW,
the whole row is stretchable.</LI>

<LI>
If a column is not stretchable, the column's width will be determined by
the widest child in the column (or the widest child of all of them if the
Matrix has PACK_UNIFORM_WIDTH has been specified).</LI>

<LI>
If a row is not stretchable, the row's height is determined by its tallest
child in the row (or tallest child of all children if PACK_UNIFORM_HEIGHT).</LI>
</OL>
The Matrix widget then arranges each child in is appropriate row/column.&nbsp;
Within the column, a child that is not stretched may be centered in the
column, or placed against the left or right side of the column; likewise,
within the row, a child that is not stretched may be centered in the row,
or placed against the top or bottom.&nbsp; Between each pair of columns,
the Matrix layout manager adds a small amount of horizontal spacing.&nbsp;
Between each pair of rows, it applies some vertical spacing.
<BR>Around the top, bottom, left, and right, the Matrix provides the usual
interior padding for visual aesthetics.

<P>The Matrix layout manager ignores hints for a specific X or Y position
of each child.
<BR>&nbsp;
<BR><U><FONT COLOR="#990000"><FONT SIZE=+4>Packer Layout Widget.</FONT></FONT></U>

<P>The Packer layout widget places its children inside a cavity, packing
them against one of the four sides, until the entire space is filled up.&nbsp;
Which side of the Packer a child is placed against is determined specifying
<B><I>one</I></B> of the side hints:
<BR>&nbsp;
<UL>
<LI>
LAYOUT_SIDE_TOP.&nbsp; Forces placement of the child against the top side
of the Packer.&nbsp; This is the default, and may not have to be specified
explicitly.</LI>

<LI>
LAYOUT_SIDE_BOTTOM. Forces placement of the child against the bottom.</LI>

<LI>
LAYOUT_SIDE_LEFT. Places the child against the left side of the Packer.</LI>

<LI>
LAYOUT_SIDE_RIGHT. Places the child against the right side of the Packer.</LI>
</UL>


<P>Each time a child is placed against one of the four sides on the inside
of the packer, it&nbsp; decreases the packer's interior by some amount.&nbsp;
If&nbsp; the child is placed at the top or bottom, the height is decreased
by the child's height; if placed against the left or right side, the width
is reduced by the child's width.

<P>Even so, the Packer tries to observe as many layout hints as feasible.&nbsp;
Thus, for a child being packed on the left or right,&nbsp; the hints LAYOUT_TOP
and LAYOUT_BOTTOM are still observed and cause the widget to be placed
against the top or bottom of the packer.&nbsp; Likewise, the LAYOUT_FILL_Y
and LAYOUT_CENTER_Y are also observed, and cause the child to stretch or
center in the packer's cavity.

<P>Analaguous to the above, when a child is packed against the top or bottom,
the Packer properly observes the LAYOUT_LEFT, LAYOUT_RIGHT, LAYOUT_FILL_X,
and LAYOUT_CENTER_X hints.

<P>There is one <I>special</I> case:&nbsp; When packing the <B>last</B>
child, the Packer observes <B>both</B> LAYOUT_CENTER_X, LAYOUT_CENTER_Y,
LAYOUT_FILL_X,&nbsp; <B>and</B> LAYOUT_FILL_Y.&nbsp; This will cause the
Packer to <B>completely fill </B>the<B> remaining space </B>of the cavity
with the<B> last child widget.</B>

<P>You can make use of this feature in a typical application by defining
your Main Viewing area as the last widget to be placed.
<BR>&nbsp;
<BR>
<HR WIDTH="100%">
<BR><FONT SIZE=-1>Copyright &copy; 1998 Jeroen van der Zijp, all rights
reserved.</FONT>
</BODY>
</HTML>
