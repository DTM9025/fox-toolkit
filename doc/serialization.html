<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Jeroen van der Zijp">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.06 [en] (X11; I; Linux 2.0.35 i586) [Netscape]">
   <META NAME="Description" CONTENT="Widget Updating">
   <META NAME="Keywords" CONTENT="FOX, GUI, Toolkit, C++ Class Library">
   <TITLE>Messages</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000" BACKGROUND="foxback.gif">

<CENTER><U><FONT COLOR="#990000"><FONT SIZE=+4>Serialization of Data and
Objects</FONT></FONT></U></CENTER>

<P><A NAME="SERIALIZATION"></A><U><FONT COLOR="#990000"><FONT SIZE=+4>What
is Serialization?</FONT></FONT></U>
<P>Often, your application needs to save and load data in a machine-independent,
binary format.&nbsp; This data may be very simple, such as an array of
numbers, or it may be a complex networks of objects arranged in some application-defined
data structure.
<P>FOX offers some tools to make implementation of such basic save and
load facilities in an application fairly straighforward: <B>Serialization</B>
and
<B>Deserialization</B>.&nbsp;&nbsp; Serialization refers to the process
of taking a network of objects and their member data, and turning it into
a linear byte stream; deserialization of course refers to the opposite.&nbsp;
This process is also sometimes referred to as <I>streaming</I>, <I>flattening</I>,
or more prosaically, <I>pickling</I>.
<P>Once code for an object's serialization has been written, this streaming
capability can be used for a variety of purposes:
<BR>&nbsp;
<UL>
<LI>
Saving or loading from <B><I>files</I></B>, in a machine-independent manner.</LI>

<LI>
Saving into <B><I>memory buffers</I></B>, or loading back from memory buffers.</LI>

<LI>
Loading of <B><I>resources</I></B> compiled into the application using
<B><I><A HREF="icons.html#RESWRAPDOC">reswrap</A></I></B>.</LI>

<LI>
Exchanging objects and data between applications using <B><I><A HREF="draganddrop.html#DRAGNDROP">Drag
and Drop</A></I></B> techniques.</LI>

<LI>
Just <B><I>counting the bytes</I></B>, e.g. to determine buffer sizes.</LI>

<LI>
Transfer objects and data over the network, e.g. via <B><I>sockets</I></B>,
<B><I>pipes</I></B>,
<B><I>PVM</I></B>, <B><I>MPI</I></B>, etc.</LI>
</UL>

<P><BR><U><FONT COLOR="#990000"><FONT SIZE=+4>Philosophy in FOX Serialization.</FONT></FONT></U>
<P>The FOX Stream classes have been designed with a number of goals in
mind:
<BR>&nbsp;
<UL>
<LI>
<B>Speed</B>.&nbsp; The serialization and deserialization should be very
fast.&nbsp; Thus, a minimal amount of computing overhead is required; also,
I/O should be minimized.</LI>

<BR>&nbsp;
<LI>
<B>Flexibility</B>.&nbsp; At some small expense in speed, all I/O eventually
boils down to a few basic virtual I/O functions; thus, it is possible to
derive subclasses and serialize data into byte streams with different destinations
or sources:- not just files, but also memory buffers, sockets, or perhaps
shared memory segments or mapped files.</LI>

<BR>&nbsp;
<LI>
<B>Type Safety</B>.&nbsp; In order to make sure that the number of bytes
saved exactly matches the number of bytes loaded, all stream insertion/extraction
operators are defined for all basic machine types, and these <I>types </I>are<I>
guaranteed </I>to be the<I> same size </I>on all FOX implementations.</LI>

<BR>&nbsp;
<LI>
<B>Byte Swapping</B>.&nbsp; Since the types are known, the FOX Stream class
is able to swap bytes upon stream deserialization.&nbsp; The FOX Stream
does NOT swap bytes on <I>saving</I>, but only on <I>loading</I>.&nbsp;
This is for the following reasons:</LI>

<BR>&nbsp;
<UL>
<LI>
It is faster to serialize in a machine-natural order, so that as long as
one works on machines of the same architecture, no cost is incurred with
swapping bytes at all.&nbsp; Loading and saving on the same type of machine
is expected to be a very, very common case.</LI>

<BR>&nbsp;
<LI>
By byte swapping on the receiving end, an <I>in-situ</I> swap can be performed,
which will lead to much better caching, and eliminates the need to temporary
buffers etc.</LI>

<BR>&nbsp;</UL>

<LI>
<B>Predictability</B>.&nbsp; With the exception of serialization of FOX
Objects, the FOX Stream class serializes exactly as many bytes as it is
given by the application.&nbsp; This has a number of interesting benefits:-
for example, the FOX GIF Image loading routine works based on a FOX Stream,
permitting it to read both from files as well as memory data arrays; this
makes handling of compiled-in or embedded resources (e.g. by using <A HREF="icons.html#RESWRAPDOC">reswrap</A>)
very simple indeed.</LI>

<BR>&nbsp;
<LI>
<B>Future expansion</B>.&nbsp; An escape tag is prepended for serialized
FOX Objects.&nbsp; This will in the [near] future allow deserialization
of FOX Objects that are available in <I>dynamic link libraries (DLL's).&nbsp;
</I>Currently, FOX can only deserialize objects that have been compiled
into the application code.</LI>
</UL>

<P><BR><U><FONT COLOR="#990000"><FONT SIZE=+4>So How Does It Work?</FONT></FONT></U>
<P>From the application programmer's point of view, it works very simply:
<BLOCKQUOTE><FONT FACE="Courier New,Courier"></FONT>&nbsp;
<BR><FONT FACE="Courier New,Courier">FXuint data[100],numdata;</FONT><FONT FACE="Courier New,Courier"></FONT>
<P><FONT FACE="Courier New,Courier">// Save my stuff to a stream</FONT>
<BR><FONT FACE="Courier New,Courier">void savemystuff(FXStream&amp; stream){</FONT>
<BR><FONT FACE="Courier New,Courier">&nbsp; stream &lt;&lt; numdata;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// Save the number of data values</FONT>
<BR><FONT FACE="Courier New,Courier">&nbsp; steam.save(data,100);&nbsp;&nbsp;&nbsp;&nbsp;
// Save the data</FONT>
<BR><FONT FACE="Courier New,Courier">&nbsp; }</FONT>
<BR><FONT FACE="Courier New,Courier"></FONT>&nbsp;<FONT FACE="Courier New,Courier"></FONT>
<P><FONT FACE="Courier New,Courier">// Save stuff to a FILE stream</FONT>
<BR><FONT FACE="Courier New,Courier">FXFileStream&nbsp; stream;</FONT>
<BR><FONT FACE="Courier New,Courier">stream.open("datafile.dat",FXStreamSave);</FONT>
<BR><FONT FACE="Courier New,Courier">savemystuff(stream);</FONT>
<BR><FONT FACE="Courier New,Courier">...</FONT>
<BR><FONT FACE="Courier New,Courier">stream.close();</FONT></BLOCKQUOTE>
As you see, this is pretty simple. Note that the code fragment doing the
actual serialization does not depend on the type of FXStream being used;
I recommend simply passing in an FXStream&amp;, so that the same code may
be used to serialize to FXFileStreams, FXMemoryStreams or other stream
classes as yet to be invented.
<BR>&nbsp;
<P>From the stream's point of view, things are a bit more complicated.&nbsp;
Saving basic types (FXchar, FXshort, etc) into an FXStream is done by C++-tradional
insertion and extraction operators <B>&lt;&lt;</B> and <B>>></B>.&nbsp;
Note that all operators take a <I>reference</I>, rather than a value.&nbsp;
If we would save a value, regular C++ type promotions might be silenty
invoked, and more bytes might be saved than expected;&nbsp; by taking reference
arguments, one has to first store a value into a variable of <I>known type</I>,
then call the insertion operator.
<P>For <I>arrays</I> of basic types, the FXStream class supplies a few
regular member functions called save() and load(), one for each basic type.&nbsp;
Note that FOX may support a type FXlong on certain machines; FXlong is
always 64 bits, or 8 bytes, if supported by the system.&nbsp; If 64 bit
numbers can not be supported, FXlong is NOT defined.
<P>For FOX Objects, things are a more complex.&nbsp; A network of objects
can be saved into a stream, and should be restored upon a load.&nbsp; Of
course, upon load not all objects will occupy the same address as where
they were initially stored from.&nbsp; Also, objects may refer to each
other;&nbsp; despite that, each object should be saved at most once.
<P>FOX currently implements the object save by means of a hash table to
translate object pointers into reference numbers and vice versa.&nbsp;
In a nutshell, here's how it works:<U></U>
<P><U>To save an object-pointer to the stream:</U>
<BR>&nbsp;
<OL>
<LI>
If the pointer is NULL, save the speciall <B>null</B> tag.<BR>
<BR></LI>

<LI>
Consult the hash table to see if the object pointer has been saved before.&nbsp;
If the object has been encountered previously, its data must already have
been saved, and the <B>reference</B> tag found in the hash table is saved
to the stream.<BR>
<BR></LI>

<LI>
If the object has never been encountered before, generate a new reference
tag, and add the object pointer and the reference tag to the hash table.&nbsp;
Subsequently, a <B>class</B> tag, an <B>escape</B> code [0 for now], and
the object's <B>class name</B> is saved to the stream.&nbsp; Then the object's
<B>member data</B> are saved by calling the object's overloaded <B>save()</B>
member function.</LI>
</OL>

<P><U>To load an object-pointer from the stream:</U>
<BR>&nbsp;
<OL>
<LI>
Read the tag.&nbsp; If the tag was the <B>null</B> tag, the pointer was
NULL, and a NULL is returned.<BR>
<BR></LI>

<LI>
If the tag was the <B>reference</B> tag, the object has already been loaded,
and the hash table is consulted to return the object-pointer.&nbsp;<BR>
<BR></LI>

<LI>
If the tag was the <B>class</B> tag, the <B>escape</B> tag is read and
[for now] discarded, and subsequently the classname is read.&nbsp; The
<B>FXMetaClass</B> is localized from the class name, and a new object is
constructed by means of its <B>makeInstance() </B>function<B>.&nbsp; </B>The
a new reference number is generated and the reference number and the object-pointer
are stored into the hash table.&nbsp; Then the object member data are loaded
by calling the object's overloaded <B>load() </B>member function.</LI>
</OL>

<P><BR>In the current implementation, only those objects whose implementation
has been compiled into the application can be [de-] serialized.
<P>Future versions of FOX will use the <B>escape</B> code information for
additional methods to localize the <B>FXMetaClass</B> objects.&nbsp; In
particular, the thinking is that certain object-implementations may live
in DLL's (Dynamic Link Libraries) and the escape code will help localize
the DLL and pull it in to provide the object implementation.&nbsp; It is
clear that this will be a very powerful mechanism, enabling for example
drag and drop of objects whose implementations are not a-priori known at
the time the application is compiled.
<P><FONT COLOR="#000000">I added the escape code so as to <B>not</B> break
people's streamed object files when this capability will be introduced.</FONT>
<BR>&nbsp;
<P><U><FONT COLOR="#990000"><FONT SIZE=+4>Future FOX uses of Serialization.</FONT></FONT></U>
<P>Serialization is not only intended for features such as saving/restoring
from files, and drag-and-drop of objects.&nbsp; Future versions of FOX
will also allow FOX GUI Widgets to be serialized or deserialized; in fact,
it is with this in mind that the two-step [Construct/Create] sequence is
so religiously carried out throughout the Library. Once FOX Widgets have
been deserialized from either an external file or perhaps from a compiled-in
[reswrapped] resource, a GUI can be created in one fell swoop with a single
call to FXApp::create().
<P>A FOX GUI Builder will be a program that builds a nice-looking GUI,
and then serializes it for incorporation into an application [using reswrap].&nbsp;
Using the escape-code mechanism, the FOX GUI builder will be able to build
GUI's that contain Custom Controls or Widgets written by third parties.
<BR>&nbsp;
<P><U><FONT COLOR="#990000"><FONT SIZE=+4>Tips and Hints for Serialization.</FONT></FONT></U>
<P><U><FONT COLOR="#990000">Byte Swapping.</FONT></U>
<P>Proper use of the serialization mechanism will allow serialized data
to be read across different machines, with different byte orders.&nbsp;
In the scope of ``predictability,'' FOX's stream mechanism does NOT contain
any tags or markers, nor does it contain things like byte order and such,
with the exception of course being the saving of object-pointers.
<P>It <I>does</I> however try to help:
<BLOCKQUOTE><FONT FACE="Courier New,Courier"></FONT>&nbsp;
<BR><FONT FACE="Courier New,Courier">FXbool FXStream::<B>isLittleEndian</B>();</FONT></BLOCKQUOTE>

<P><BR>returns <I>TRUE</I> for Little Endian machines [e.g. i386 and Alpha
CPU's] and <I>FALSE</I> for Big Endian machines [e.g. 68k, SPARC CPU's].
<BR>Note that <B>FXbool</B> is defined as <B>FXuchar</B>, NOT as C++ <B>bool</B>.&nbsp;
[I've never been able to find a statement that says how big the standard
type <B>bool</B> is, but I'm pretty sure a char is 1 byte!].
<P>Thus, the following chunk of code may be executed before saving any
actual application data:
<BR>&nbsp;
<BLOCKQUOTE><FONT FACE="Courier New,Courier">FXbool endianness=FXStream::isLittleEndian();</FONT>
<BR><FONT FACE="Courier New,Courier">stream &lt;&lt; endianness;</FONT>
<BR><FONT FACE="Courier New,Courier">....</FONT>
<BR><I><FONT FACE="Courier New,Courier">save the data</FONT></I>
<BR><FONT FACE="Courier New,Courier">....</FONT>
<BR><FONT FACE="Courier New,Courier"></FONT>&nbsp;</BLOCKQUOTE>
Then upon loading:
<BR>&nbsp;
<BLOCKQUOTE><FONT FACE="Courier New,Courier">FXbool endianness;</FONT>
<BR><FONT FACE="Courier New,Courier">stream >> endianness;</FONT>
<BR><FONT FACE="Courier New,Courier">stream.swapBytes(endianness!=FXStream::isLittleEndian());</FONT>
<BR><FONT FACE="Courier New,Courier">....</FONT>
<BR><I><FONT FACE="Courier New,Courier">load the data</FONT></I>
<BR><FONT FACE="Courier New,Courier">....</FONT></BLOCKQUOTE>
In other words, the bytes are swapped on input, if and only if<I> </I>the
byte order of the saving application <I>differs</I> from the loading one.
<BR>&nbsp;
<P><U><FONT COLOR="#990000">Container Object.</FONT></U>
<P>Many applications have one so-called <B>container</B> object, which
may not itself participate in serialization for one reason or another.&nbsp;
For example, the FOX FXApp object is normally created by the main startup
routine of an application, and will probably never be serialized [although
its member data may be].
<P>In order to accomodate references to such an object without saving it,
the FXStream class allows you to specify a <B>container</B> object.&nbsp;
During serialization, when a pointer to the container object is encountered,
only a reference tag is saved to the stream; likewise, on deserialization
a reference to the container object is translated into the pointer passed
in with the FXStream constructor.
<BR>&nbsp;
<P><U><FONT COLOR="#990000">Use FX Types.</FONT></U>
<P>FOX defines a number of typedefs for the basic types, such as FXchar,
FXshort, and so on.&nbsp; The idea is that the size of these types is <I>fixed</I>,
and the <I>same</I> on all implementations; there is an FXASSERT somewhere
that will trip if this is not true.
<P>Writing applications that should work on heterogeneous mixes of hardware
becomes simpler if variables you intend to serialize are defined in terms
of these basic types; for loop variables and such ephemeral things, you
may want to use the ``suggested'' system-specific types, as these may be
faster.
<P>The type <B>FXlong</B> may NOT be available on all platforms.&nbsp;
It represents a 64 bit integer type.&nbsp; You use this at your own risk
of potential portability loss.
<BR>&nbsp;
<P>
<HR WIDTH="100%">
<BR><FONT SIZE=-1>Copyright &copy; 1998 <A HREF="mailto:jvz@cfdrc.com">Jeroen
van der Zijp</A>, all rights reserved.</FONT>
</BODY>
</HTML>
